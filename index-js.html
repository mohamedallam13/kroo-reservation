<script>
  /**
 * KROO Reservations App - Optimized JavaScript
 * 
 * This file contains all the JavaScript functionality for the KROO Reservations application,
 * organized in a more modular and maintainable way.
 */

  // ===== APP CONFIGURATION =====
  const CONFIG = {
    businessHours: {
      start: 9, // 9:00 AM
      end: 23   // 11:00 PM
    }
  };//

  // ===== MOCK DATA =====
  // These would be replaced with API calls in a production environment
  let resources = [
    {
      id: 1,
      name: "Overlook Conference Room",
      image: "/api/placeholder/400/260",
      capacity: 8,
      status: "available",
      location: "3rd Floor, East Wing",
      pricePerHour: 100 // EGP per hour
    },
    {
      id: 2,
      name: "Focus Pod A",
      image: "/api/placeholder/400/260",
      capacity: 2,
      status: "available",
      location: "2nd Floor, North Wing",
      pricePerHour: 75 // EGP per hour
    },
    {
      id: 3,
      name: "Executive Meeting Room",
      image: "/api/placeholder/400/260",
      capacity: 12,
      status: "available",
      location: "5th Floor, West Wing",
      pricePerHour: 150 // EGP per hour
    },
    {
      id: 4,
      name: "Creative Studio",
      image: "/api/placeholder/400/260",
      capacity: 6,
      status: "maintenance",
      location: "1st Floor, South Wing",
      pricePerHour: 120 // EGP per hour
    },
    {
      id: 5,
      name: "Corner Office",
      image: "/api/placeholder/400/260",
      capacity: 4,
      status: "available",
      location: "4th Floor, East Wing",
      pricePerHour: 90 // EGP per hour
    },
    {
      id: 6,
      name: "Garden Lounge",
      image: "/api/placeholder/400/260",
      capacity: 10,
      status: "available",
      location: "Ground Floor, Central",
      pricePerHour: 110 // EGP per hour
    }
  ];

  // Updated bookings array with user information
  // Add this to your existing code where the bookings array is defined

  let bookings = [
    {
      id: 101,
      resourceId: 1,
      resourceName: "Overlook Conference Room",
      date: getDateString(0), // Today
      startTime: "09:00",
      endTime: "11:00",
      status: "CONFIRMED",
      price: 200, // EGP
      paymentMethod: "credit-card",
      paymentStatus: "completed",
      // Added user information
      userDetails: {
        email: "john.doe@example.com",
        name: "John Doe",
        phone: "+20 123 456 7890"
      },
      // Metadata about who created the booking
      createdBy: {
        email: "john.doe@example.com",
        isAdmin: false
      }
    },
    {
      id: 102,
      resourceId: 3,
      resourceName: "Executive Meeting Room",
      date: getDateString(-3), // 3 days ago
      startTime: "14:00",
      endTime: "16:00",
      status: "EXPIRED",
      price: 300, // EGP
      paymentMethod: "instapay",
      paymentStatus: "completed",
      // Added user information
      userDetails: {
        email: "sarah.smith@example.com",
        name: "Sarah Smith",
        phone: "+20 123 456 7891"
      },
      // Booking created by admin
      createdBy: {
        email: "admin@example.com",
        isAdmin: true
      }
    },
    {
      id: 103,
      resourceId: 2,
      resourceName: "Focus Pod A",
      date: getDateString(5), // 5 days from now
      startTime: "10:00",
      endTime: "12:00",
      status: "CONFIRMED",
      price: 150, // EGP
      paymentMethod: "cash",
      paymentStatus: "pending",
      // Added user information
      userDetails: {
        email: "ahmed.ibrahim@example.com",
        name: "Ahmed Ibrahim",
        phone: "+20 111 222 3333"
      },
      // Self-booking
      createdBy: {
        email: "ahmed.ibrahim@example.com",
        isAdmin: false
      }
    }
  ];

  let bookedSlots = [
    { resourceId: 1, date: getDateString(0), startTime: "09:00", endTime: "11:00" }, // Today
    { resourceId: 1, date: getDateString(0), startTime: "14:00", endTime: "15:00" }, // Today
    { resourceId: 1, date: getDateString(1), startTime: "11:00", endTime: "13:00" }, // Tomorrow 
    { resourceId: 2, date: getDateString(0), startTime: "13:00", endTime: "17:00" }, // Today
    { resourceId: 3, date: getDateString(0), startTime: "09:00", endTime: "12:00" }, // Today
    { resourceId: 3, date: getDateString(2), startTime: "15:00", endTime: "17:00" }  // Day after tomorrow
  ];


  // Updated payment methods array with logo images
  const paymentMethods = [
    {
      id: "credit-card",
      name: "Credit Card",
      description: "Pay securely with Visa, Mastercard, or Amex",
      icon: "https://cdn-icons-png.flaticon.com/512/179/179457.png",
      requiresVerification: false,
      type: "online"
    },
    {
      id: "instapay",
      name: "Instapay",
      description: "Transfer via bank Instapay system",
      icon: "https://lh3.googleusercontent.com/d/1DPVAkeLCYYdRrIbd3JK1WDAw874sheWS",
      requiresVerification: true,
      type: "transfer"
    },
    {
      id: "cash",
      name: "Cash",
      description: "Pay in cash when you arrive",
      icon: "https://cdn-icons-png.flaticon.com/512/2489/2489756.png",
      requiresVerification: false,
      type: "in-person"
    }
  ];

  // Global users data for admin dropdown
  window.appUsers = [
    {
      email: "john.doe@example.com",
      name: "John Doe",
      phone: "+20 123 456 7890",
      discount: 5
    },
    {
      email: "sarah.smith@example.com",
      name: "Sarah Smith",
      phone: "+20 123 456 7891",
      discount: 10
    },
    {
      email: "ahmed.ibrahim@example.com",
      name: "Ahmed Ibrahim",
      phone: "+20 111 222 3333",
      discount: 0
    },
    {
      email: "nora.hassan@example.com",
      name: "Nora Hassan",
      phone: "+20 222 333 4444",
      discount: 15
    },
    {
      email: "michael.chen@example.com",
      name: "Michael Chen",
      phone: "+20 555 666 7777",
      discount: 5
    },
    {
      email: "fatima.ali@example.com",
      name: "Fatima Ali",
      phone: "+20 777 888 9999",
      discount: 20
    },
    {
      email: "omar.mahmoud@example.com",
      name: "Omar Mahmoud",
      phone: "+20 444 555 6666",
      discount: 0
    },
    {
      email: "leila.karim@example.com",
      name: "Leila Karim",
      phone: "+20 888 999 0000",
      discount: 5
    },
    {
      email: "david.wang@example.com",
      name: "David Wang",
      phone: "+20 333 222 1111",
      discount: 10
    },
    {
      email: "amina.nasser@example.com",
      name: "Amina Nasser",
      phone: "+20 999 888 7777",
      discount: 0
    }
  ];

  // Helper function to get date string for today +/- days
  function getDateString(dayOffset = 0) {
    const date = new Date();
    date.setDate(date.getDate() + dayOffset);
    return date.toISOString().split('T')[0]; // Format as YYYY-MM-DD
  }

  // ===== APP STATE =====
  const AppState = {
    // Booking properties
    currentResourceId: null,
    selectedDateValue: null,
    selectedTimeSlot: null,
    selectedPaymentMethod: null,
    bookingReference: null,
    paymentReference: null,
    uploadedFile: null,
    verifiedPayments: [],
    currentBookingFilter: 'upcoming',
    isSubmitting: false,

    // User properties
    userEmail: '',
    userName: '',
    userPhone: '',
    userDiscount: 0,
    isAdmin: false,

    // Locked mode property - set once and never changes
    initialMode: null,

    // Mode detection using locked mode
    getUserMode: function () {
      // If we've already determined the initial mode, use that
      if (this.initialMode) {
        return this.initialMode;
      }

      // Otherwise, determine it now and lock it in
      if (this.isAdmin) {
        this.initialMode = 'admin';
      } else if (this.hasUserEmail()) {
        this.initialMode = 'user';
      } else {
        this.initialMode = 'guest';
      }

      return this.initialMode;
    },

    // Initialize user from hidden inputs AND URL parameters
    initializeUser: function () {
      // Get data from hidden inputs with null checks
      const emailInput = document.getElementById('user-email');
      const nameInput = document.getElementById('user-name');
      const phoneInput = document.getElementById('user-phone');
      const discountInput = document.getElementById('user-discount');
      const adminInput = document.getElementById('is-admin');

      this.userEmail = emailInput ? emailInput.value : '';
      this.userName = nameInput ? nameInput.value : '';
      this.userPhone = phoneInput ? phoneInput.value : '';
      this.userDiscount = parseFloat(discountInput ? discountInput.value : '0') || 0;
      this.isAdmin = adminInput ? adminInput.value === 'true' : false;

      // Override with URL parameters if provided
      const urlParams = this.getUrlParameters();
      if (urlParams.email) this.userEmail = urlParams.email;
      if (urlParams.name) this.userName = urlParams.name;
      if (urlParams.phone) this.userPhone = urlParams.phone;
      if (urlParams.discount) this.userDiscount = parseFloat(urlParams.discount);
      if (urlParams.admin) this.isAdmin = urlParams.admin === 'true';

      // IMPORTANT: Lock in the mode based on initial state
      this.initialMode = null; // Reset first
      const mode = this.getUserMode(); // This will set and lock the mode

      // Clear bookings cache when user changes
      this.dataLoaded.bookings = false;

      console.log('User initialized:', {
        email: this.userEmail,
        name: this.userName,
        phone: this.userPhone,
        discount: this.userDiscount,
        isAdmin: this.isAdmin,
        mode: mode,
        lockedMode: this.initialMode,
        source: urlParams.email ? 'URL parameters' : 'hidden inputs'
      });

      setupDiscountBanner();
    },

    // Extract URL parameters
    getUrlParameters: function () {
      const params = new URLSearchParams(window.location.search);
      return {
        email: params.get('email') || params.get('userEmail'),
        name: params.get('name') || params.get('userName') || params.get('fullName'),
        phone: params.get('phone') || params.get('phoneNumber') || params.get('userPhone'),
        discount: params.get('discount') || params.get('userDiscount'),
        admin: params.get('admin') || params.get('isAdmin')
      };
    },

    // Check if user email is provided
    hasUserEmail: function () {
      return this.userEmail !== '';
    },

    // Check if we have complete user details
    hasCompleteUserDetails: function () {
      return this.userEmail !== '' && this.userName !== '' && this.userPhone !== '';
    },

    // Set user details from form
    setUserDetails: function (userData) {
      this.userEmail = userData.email || this.userEmail;
      this.userName = userData.name || this.userName;
      this.userPhone = userData.phone || this.userPhone;
      this.userDiscount = userData.discount !== undefined ? userData.discount : this.userDiscount;
      this.isNewUser = userData.isNewUser || false

      console.log('User details updated:', {
        email: this.userEmail,
        name: this.userName,
        phone: this.userPhone,
        discount: this.userDiscount,
        isNewUser: this.isNewUser,
        lockedMode: this.initialMode // Show locked mode, not current derived mode
      });
    },

    // New method to safely handle submissions
    beginSubmission: function () {
      if (this.isSubmitting) {
        console.warn('Submission already in progress, preventing duplicate submission');
        return false;
      }
      this.isSubmitting = true;
      return true;
    },

    endSubmission: function () {
      this.isSubmitting = false;
    },

    // Generate or retrieve booking reference consistently
    getBookingReference: function () {
      // Generate new reference if one doesn't exist
      if (!this.bookingReference) {
        this.bookingReference = Utils.generateBookingReference();
      }
      return this.bookingReference;
    },

    // Generate or retrieve payment reference consistently
    getPaymentReference: function () {
      // Generate new reference if one doesn't exist
      if (!this.paymentReference) {
        this.paymentReference = Utils.generateReferenceNumber();
      }
      return this.paymentReference;
    },

    // Reset references when booking is complete
    resetReferences: function () {
      this.bookingReference = null;
      this.paymentReference = null;
    },

    // Add this property:
    dataLoaded: {
      resources: false,
      bookedSlots: false,
      bookings: false
    }
  };

  // ===== DOM MANIPULATION HELPERS =====
  const DOM = {
    /**
     * Get an element by ID
     * @param {string} id - Element ID
     * @returns {HTMLElement|null} The element or null if not found
     */
    byId: (id) => document.getElementById(id),

    /**
     * Create an element from a template
     * @param {string} templateId - Template ID
     * @returns {DocumentFragment|null} The cloned template content
     */
    createFromTemplate: (templateId) => {
      const template = document.getElementById(templateId);
      return template ? template.content.cloneNode(true) : null;
    },

    /**
     * Show an element
     * @param {HTMLElement} element - Element to show
     * @param {string} [display='block'] - Display value
     */
    show: (element, display = 'block') => {
      if (element) element.style.display = display;
    },

    /**
     * Hide an element
     * @param {HTMLElement} element - Element to hide
     */
    hide: (element) => {
      if (element) element.style.display = 'none';
    },

    /**
     * Add a class to an element
     * @param {HTMLElement} element - Element to modify
     * @param {string} className - Class to add
     */
    addClass: (element, className) => {
      if (element) element.classList.add(className);
    },

    /**
     * Remove a class from an element
     * @param {HTMLElement} element - Element to modify
     * @param {string} className - Class to remove
     */
    removeClass: (element, className) => {
      if (element) element.classList.remove(className);
    },

    /**
     * Toggle a class on an element
     * @param {HTMLElement} element - Element to modify
     * @param {string} className - Class to toggle
     * @param {boolean} [force] - Force add or remove
     */
    toggleClass: (element, className, force) => {
      if (element) element.classList.toggle(className, force);
    }
  };

  // ===== UTILITY FUNCTIONS =====
  const Utils = {
    /**
     * Convert HH:MM time to minutes since midnight
     * @param {string} timeString - Time in HH:MM format
     * @returns {number} Minutes since midnight
     */
    convertTimeToMinutes: (timeString) => {
      const [hours, minutes] = timeString.split(':').map(Number);
      return hours * 60 + minutes;
    },

    /**
     * Format time from HH:MM to 12-hour format (e.g., "9 AM", "2:30 PM")
     * @param {string} timeString - Time in HH:MM format
     * @returns {string} Formatted time
     */
    formatTime: (timeString) => {
      if (!timeString) return '';

      const [hours, minutes] = timeString.split(':').map(Number);
      const hour = parseInt(hours);

      const suffix = hour >= 12 ? 'PM' : 'AM';
      const displayHour = hour % 12 || 12;

      return `${displayHour}${minutes !== 0 ? ':' + minutes.toString().padStart(2, '0') : ''} ${suffix}`;
    },

    /**
     * Format duration in hours to a readable string
     * @param {number} hours - Duration in hours
     * @returns {string} Formatted duration
     */
    formatDuration: (hours) => {
      if (hours === 1) {
        return "1 hour";
      } else if (hours < 1) {
        const minutes = Math.round(hours * 60);
        return `${minutes} min`;
      } else {
        const wholeHours = Math.floor(hours);
        const minutes = Math.round((hours - wholeHours) * 60);

        if (minutes === 0) {
          return `${wholeHours} hour${wholeHours > 1 ? 's' : ''}`;
        } else {
          return `${wholeHours} hour${wholeHours > 1 ? 's' : ''} ${minutes} min`;
        }
      }
    },

    /**
     * Capitalize the first letter of a string
     * @param {string} string - String to capitalize
     * @returns {string} Capitalized string
     */
    capitalizeFirstLetter: (string) => {
      return string.charAt(0).toUpperCase() + string.slice(1);
    },

    /**
     * Calculate booking price with discount
     * @param {number} basePrice - Original price before discount
     * @param {number} userDiscount - Discount percentage (0-100)
     * @returns {object} Price details including original, discount amount, and final price
     */
    calculateBookingPrice: (basePrice, userDiscount = 0) => {
      // Ensure discount is a valid number
      const discount = parseFloat(userDiscount) || 0;

      // Calculate the discount amount
      const discountAmount = (basePrice * discount) / 100;

      // Calculate final price with discount applied
      const finalPrice = basePrice - discountAmount;

      return {
        originalPrice: basePrice,
        discountAmount: discountAmount,
        finalPrice: finalPrice,
        discountPercentage: discount
      };
    },

    /**
     * Generate a random reference number
     * @returns {string} Random reference number with date prefix
     */
    generateReferenceNumber: () => {
      const today = new Date();
      const refDate = `${today.getFullYear().toString().substr(2)}${(today.getMonth() + 1).toString().padStart(2, '0')}${today.getDate().toString().padStart(2, '0')}`;
      const refNum = Math.floor(10000 + Math.random() * 90000);
      return refDate + refNum;
    },

    /**
     * Generate a unique booking reference number
     * Format: KROO-[YYYYMMDD]-[5 random digits]
     * @returns {string} Booking reference number
     */
    generateBookingReference: () => {
      const today = new Date();
      const dateStr = today.getFullYear() +
        (today.getMonth() + 1).toString().padStart(2, '0') +
        today.getDate().toString().padStart(2, '0');

      // Generate 5 random digits
      const randomPart = Math.floor(10000 + Math.random() * 90000);

      return `KROO-${dateStr}-${randomPart}`;
    }
  };

  // ===== TOAST NOTIFICATIONS =====
  const Toast = {
    /**
     * Show a toast notification
     * @param {string} type - Toast type ('success', 'error', 'info')
     * @param {string} message - Toast message
     */
    show: (type, message) => {
      // Check if there's an existing toast and remove it
      const existingToast = document.querySelector('.toast.active');
      if (existingToast) {
        existingToast.remove();
      }

      // Create new toast
      const toast = document.createElement('div');
      toast.className = `toast ${type === 'success' ? 'toast-success' : type === 'error' ? 'toast-error' : 'toast-info'}`;

      // Icon based on type
      let iconHtml = '';
      if (type === 'success') {
        iconHtml = `
        <div class="toast-icon">
          <div class="toast-icon-success">
            <i class="fas fa-check"></i>
          </div>
        </div>
      `;
      } else if (type === 'error') {
        iconHtml = `
        <div class="toast-icon">
          <div class="toast-icon-error">
            <i class="fas fa-times"></i>
          </div>
        </div>
      `;
      } else {
        iconHtml = `
        <div class="toast-icon">
          <div style="background-color: #3B82F6; color: white; border-radius: 50%; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center;">
            <i class="fas fa-info"></i>
          </div>
        </div>
      `;
      }

      toast.innerHTML = `
      ${iconHtml}
      <div class="toast-message">${message}</div>
    `;

      // Add to document
      document.body.appendChild(toast);

      // Show toast
      setTimeout(() => {
        toast.classList.add('active');
      }, 10);

      // Auto hide after 3 seconds
      setTimeout(() => {
        toast.classList.remove('active');
        setTimeout(() => {
          toast.remove();
        }, 300);
      }, 3000);
    }
  };


  // ===== UI COMPONENTS =====
  const UI = {
    // Navigation and views
    showResourcesView: () => {
      const resourcesView = DOM.byId('resources-view');
      const bookingsView = DOM.byId('bookings-view');
      const tabResources = DOM.byId('tab-resources');
      const tabBookings = DOM.byId('tab-bookings');

      if (resourcesView && bookingsView && tabResources && tabBookings) {
        DOM.show(resourcesView, 'grid');
        DOM.hide(bookingsView);

        DOM.addClass(tabResources, 'active');
        DOM.removeClass(tabBookings, 'active');
      }
    },

    showBookingsView: () => {
      const resourcesView = DOM.byId('resources-view');
      const bookingsView = DOM.byId('bookings-view');
      const tabResources = DOM.byId('tab-resources');
      const tabBookings = DOM.byId('tab-bookings');

      if (resourcesView && bookingsView && tabResources && tabBookings) {
        DOM.hide(resourcesView);
        DOM.show(bookingsView);

        DOM.removeClass(tabResources, 'active');
        DOM.addClass(tabBookings, 'active');

        UI.renderBookings();
      }
    },

    setBookingFilter: (filter) => {
      AppState.currentBookingFilter = filter;

      const filterUpcoming = DOM.byId('filter-upcoming');
      const filterPast = DOM.byId('filter-past');

      if (filterUpcoming && filterPast) {
        if (filter === 'upcoming') {
          DOM.addClass(filterUpcoming, 'active');
          DOM.removeClass(filterPast, 'active');
        } else {
          DOM.removeClass(filterUpcoming, 'active');
          DOM.addClass(filterPast, 'active');
        }

        UI.renderBookings();
      }
    },

    // Resource rendering
    renderResources: () => {
      const resourcesContainer = DOM.byId('resources-view');
      if (!resourcesContainer) return;

      // Show skeleton loaders while resources are loading
      LoadingManager.showSkeletonLoader(resourcesContainer, 'rect', 3);

      // Use the API module to fetch resources
      API.fetchResourcesAndSlots()
        .then(fetchedResources => {
          // Hide skeleton loaders
          LoadingManager.hideSkeletonLoader(resourcesContainer);

          // Clear container
          resourcesContainer.innerHTML = '';

          // Render each resource
          fetchedResources.forEach(resource => {
            const card = document.createElement('div');
            card.className = 'resource-card';

            const statusBadgeClass = resource.status === 'available'
              ? 'status-badge available'
              : 'status-badge maintenance';

            card.innerHTML = `
  <div class="card-image" data-resource-id="${resource.id}">
    <img src="${resource.image}" alt="${resource.name}" loading="lazy">
    <div class="image-overlay">
      <i class="fas fa-expand"></i>
    </div>
    <div class="${statusBadgeClass}">
      ${Utils.capitalizeFirstLetter(resource.status)}
    </div>
  </div>
  <div class="card-content">
    <h3 class="card-title">${resource.name}</h3>
    <div class="card-details">
      <div class="detail-item">
        <i class="fas fa-map-marker-alt"></i>
        <span>${resource.location}</span>
      </div>
      <div class="detail-item">
        <i class="fas fa-users"></i>
        <span>Capacity: ${resource.capacity} people</span>
      </div>
      <div class="detail-item">
        <i class="fas fa-money-bill-wave"></i>
        <span>EGP ${resource.pricePerHour}/hour</span>
      </div>
    </div>
    <div class="card-actions">
      <button 
        class="btn ${resource.status === 'available' ? 'btn-primary' : 'btn-disabled'}"
        ${resource.status !== 'available' ? 'disabled' : ''}
        data-resource-id="${resource.id}"
      >
        Book Now
      </button>
    </div>
  </div>
`;

            resourcesContainer.appendChild(card);

            // Add event listener for image carousel
            const cardImage = card.querySelector('.card-image');
            if (cardImage && resource.carouselImages && resource.carouselImages.length > 0) {
              cardImage.addEventListener('click', function (event) {
                event.stopPropagation();
                ImageCarousel.open(resource);
              });
            }

            // Add event listener to the Book Now button (existing code)
            const bookButton = card.querySelector('button[data-resource-id]');
            if (resource.status === 'available' && bookButton) {
              bookButton.addEventListener('click', () => {
                BookingModal.open(resource.id);
              });
            }

          });
        })
        .catch(error => {
          // Hide skeleton loaders
          LoadingManager.hideSkeletonLoader(resourcesContainer);

          // Show error message in container
          resourcesContainer.innerHTML = `
        <div class="error-container">
          <i class="fas fa-exclamation-circle error-icon"></i>
          <h3>Could not load resources</h3>
          <p>${error.message || 'Please try again later.'}</p>
          <button class="btn btn-primary retry-button">
            <i class="fas fa-sync"></i> Retry
          </button>
        </div>
      `;

          // Add event listener to retry button
          const retryButton = resourcesContainer.querySelector('.retry-button');
          if (retryButton) {
            retryButton.addEventListener('click', UI.renderResources);
          }

          // Show error toast
          Toast.show('error', 'Could not load resources. Please try again later.');
          console.error('Error loading resources:', error);
        });
    },

    // Bookings rendering
    renderBookings: () => {
      const bookingsList = DOM.byId('bookings-list');
      if (!bookingsList) return;

      // Show section loader
      LoadingManager.showSectionLoader('#bookings-view');

      // Simulate API call to get bookings
      setTimeout(() => {
        // Hide section loader
        LoadingManager.hideSectionLoader('#bookings-view');

        // Clear bookings list
        bookingsList.innerHTML = '';

        // Filter bookings based on current filter
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        console.log('Bookings:', bookings);

        let filteredBookings = bookings.filter(booking => {
          const bookingDate = new Date(booking.date);
          bookingDate.setHours(0, 0, 0, 0);

          if (AppState.currentBookingFilter === 'upcoming') {
            return bookingDate >= today && booking.status !== 'CANCELED';
          } else {
            return bookingDate < today || booking.status === 'CANCELED' || booking.status === 'EXPIRED';
          }
        });

        console.log('Filtered bookings:', filteredBookings);

        // // Additional filtering based on user role
        // if (!AppState.isAdmin) {
        //   // Non-admin users only see their own bookings
        //   filteredBookings = filteredBookings.filter(booking => {
        //     // Check if booking has userDetails with matching email
        //     return booking.userDetails &&
        //       booking.userDetails.email === AppState.userEmail;
        //   });
        // } //OLD FROM OLD CHECKS

        // Display message if no bookings
        if (filteredBookings.length === 0) {
          bookingsList.innerHTML = `
        <div class="text-center" style="padding: 2.5rem 0; text-align: center;">
          <i class="far fa-calendar-alt" style="color: #E5E7EB; font-size: 2rem; margin-bottom: 0.75rem;"></i>
          <p style="color: #6B7280;">No ${AppState.currentBookingFilter} bookings found.</p>
        </div>
      `;
          return;
        }

        // Render each booking
        filteredBookings.forEach(booking => {
          const card = document.createElement('div');
          card.className = 'booking-card';

          // Format date
          const bookingDate = new Date(booking.date);
          const formattedDate = bookingDate.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
          });

          // Status badge class
          let statusBadgeClass = '';
          switch (booking.status) {
            case 'CONFIRMED':
              statusBadgeClass = 'badge-confirmed';
              break;
            case 'CANCELED':
              statusBadgeClass = 'badge-canceled';
              break;
            case 'EXPIRED':
              statusBadgeClass = 'badge-expired';
              break;
            default:
              statusBadgeClass = 'badge-confirmed';
          }

          // Payment method information
          const paymentMethod = booking.paymentMethod || 'online';
          const paymentStatus = booking.paymentStatus || 'completed';

          // Get payment method details if available
          const paymentMethodObj = paymentMethods.find(m => m.id === paymentMethod);
          const paymentMethodName = paymentMethodObj ? paymentMethodObj.name : Utils.capitalizeFirstLetter(paymentMethod);

          // Payment status badge
          let paymentStatusBadge = '';
          if (paymentMethod === 'cash' && paymentStatus === 'pending') {
            paymentStatusBadge = `<span class="payment-badge payment-pending">Pay on arrival</span>`;
          } else if (paymentStatus === 'completed') {
            paymentStatusBadge = `<span class="payment-badge payment-completed">Paid</span>`;
          } else if (paymentStatus === 'failed') {
            paymentStatusBadge = `<span class="payment-badge payment-failed">Payment failed</span>`;
          }

          // Check if booking can be canceled
          const canCancel = booking.status === 'CONFIRMED' &&
            new Date(`${booking.date}T${booking.endTime}`) > new Date();

          // Prepare user information display
          const userInfo = booking.userDetails ? `
        <div class="detail-item">
          <i class="fas fa-user"></i>
          <span>${booking.userDetails.name}</span>
        </div>
      ` : '';

          // Admin-only: Show who created the booking if different from user
          const createdByInfo = (AppState.isAdmin &&
            booking.createdBy &&
            booking.userDetails &&
            booking.createdBy.email !== booking.userDetails.email) ? `
        <div class="detail-item admin-info">
          <i class="fas fa-user-shield"></i>
          <span>Booked by: ${booking.createdBy.email}</span>
        </div>
      ` : '';

          card.innerHTML = `
        <div class="booking-header">
          <h3 class="booking-title">${booking.resourceName}</h3>
          <span class="booking-badge ${statusBadgeClass}">${booking.status}</span>
        </div>
        <div class="booking-details">
          <div class="detail-item">
            <i class="far fa-calendar-alt"></i>
            <span>${formattedDate}</span>
          </div>
          <div class="detail-item">
            <i class="far fa-clock"></i>
            <span>${Utils.formatTime(booking.startTime)} - ${Utils.formatTime(booking.endTime)}</span>
          </div>
          <div class="detail-item">
            <i class="fas fa-money-bill-wave"></i>
            <span>EGP ${booking.price.toFixed(2)}</span>
          </div>
          <div class="detail-item">
            <i class="fas fa-credit-card"></i>
            <span>${paymentMethodName} ${paymentStatusBadge}</span>
          </div>
          ${userInfo}
          ${createdByInfo}
        </div>
        ${canCancel ? `
          <button class="btn btn-outline btn-danger" data-booking-id="${booking.id}">
            Cancel Booking
          </button>
        ` : ''}
      `;

          bookingsList.appendChild(card);

          // Add event listener to cancel button if present
          if (canCancel) {
            const cancelButton = card.querySelector('button[data-booking-id]');
            if (cancelButton) {
              cancelButton.addEventListener('click', () => {
                CancelModal.open(booking.id);
              });
            }
          }
        });
      }, 800);
    },

    showBookingSkeletons: () => {
      const bookingsList = DOM.byId('bookings-list');
      if (!bookingsList) return;

      bookingsList.innerHTML = '';

      for (let i = 0; i < 4; i++) {
        const skeletonCard = document.createElement('div');
        skeletonCard.className = 'booking-card skeleton-booking';

        skeletonCard.innerHTML = `
      <div class="skeleton-booking-header">
        <div class="skeleton-line skeleton-title"></div>
        <div class="skeleton-badge"></div>
      </div>
      <div class="skeleton-booking-details">
        <div class="skeleton-detail">
          <div class="skeleton-icon"></div>
          <div class="skeleton-line skeleton-text"></div>
        </div>
        <div class="skeleton-detail">
          <div class="skeleton-icon"></div>
          <div class="skeleton-line skeleton-text"></div>
        </div>
      </div>
    `;

        bookingsList.appendChild(skeletonCard);
      }

      if (!document.getElementById('booking-skeleton-styles')) {
        const skeletonStyles = document.createElement('style');
        skeletonStyles.id = 'booking-skeleton-styles';
        skeletonStyles.textContent = `
      .skeleton-booking {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        animation: skeleton-pulse 1.5s ease-in-out infinite alternate;
      }
      .skeleton-booking-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }
      .skeleton-booking-details {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .skeleton-detail {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .skeleton-line {
        background: #e9ecef;
        border-radius: 4px;
        height: 1rem;
      }
      .skeleton-title { width: 60%; height: 1.25rem; }
      .skeleton-text { width: 45%; }
      .skeleton-badge { width: 80px; height: 24px; background: #e9ecef; border-radius: 12px; }
      .skeleton-icon { width: 16px; height: 16px; background: #e9ecef; border-radius: 2px; }
      @keyframes skeleton-pulse { 0% { opacity: 1; } 100% { opacity: 0.6; } }
    `;
        document.head.appendChild(skeletonStyles);
      }
    },

    // Time visualization
    createTimeVisualization: () => {
      // Create container for time visualization
      const container = document.createElement('div');
      container.className = 'time-visualization';

      // Create track
      const track = document.createElement('div');
      track.className = 'time-track';
      container.appendChild(track);

      // Generate time labels based on business hours
      const labels = document.createElement('div');
      labels.className = 'time-labels';

      // Get business hours from CONFIG
      const startHour = CONFIG.businessHours.start;
      const endHour = CONFIG.businessHours.end;

      // Calculate how many labels to show (don't want too many to avoid crowding)
      // We'll show approx 5-6 labels total including start and end
      const totalHours = endHour - startHour;
      const interval = Math.max(Math.floor(totalHours / 5), 1); // At least 1 hour intervals

      // Generate label HTML
      let labelsHTML = '';

      // Always include the start hour
      labelsHTML += `<span>${Utils.formatTime(startHour.toString().padStart(2, '0') + ':00')}</span>`;

      // Add intermediate labels
      for (let hour = startHour + interval; hour < endHour; hour += interval) {
        // Skip if too close to start or end to avoid crowding
        if (hour > startHour + interval / 2 && hour < endHour - interval / 2) {
          labelsHTML += `<span>${Utils.formatTime(hour.toString().padStart(2, '0') + ':00')}</span>`;
        }
      }

      // Always include the end hour
      labelsHTML += `<span>${Utils.formatTime(endHour.toString().padStart(2, '0') + ':00')}</span>`;

      labels.innerHTML = labelsHTML;
      container.appendChild(labels);

      // Create selection indicator
      const selection = document.createElement('div');
      selection.className = 'time-selection';
      selection.style.display = 'none';
      container.appendChild(selection);

      // Create booked segments container
      const bookedContainer = document.createElement('div');
      bookedContainer.className = 'time-booked';
      container.appendChild(bookedContainer);

      return container;
    },

    updateTimeVisualization: (bookedSlots) => {
      // Get or create the visualization container
      let timeVisualization = document.querySelector('.time-visualization');
      if (!timeVisualization) {
        timeVisualization = UI.createTimeVisualization();
        const timeSlots = DOM.byId('time-slots');
        if (timeSlots) {
          timeSlots.parentNode.insertBefore(timeVisualization, timeSlots.nextSibling);
        }
      }

      // Get or create the booked segments container
      let timeBooked = timeVisualization.querySelector('.time-booked');
      if (!timeBooked) {
        timeBooked = document.createElement('div');
        timeBooked.className = 'time-booked';
        timeVisualization.appendChild(timeBooked);
      }

      // Clear existing booked segments
      timeBooked.innerHTML = '';

      // Reset time selection
      const timeSelection = timeVisualization.querySelector('.time-selection');
      if (timeSelection) {
        timeSelection.style.display = 'none';
      }

      // Calculate the total minutes in the day
      const startOfDay = CONFIG.businessHours.start * 60; // 9 AM in minutes
      const totalMinutes = (CONFIG.businessHours.end - CONFIG.businessHours.start) * 60;

      // Add booked slot indicators as separate child elements
      bookedSlots.forEach(slot => {
        const bookedStartMinutes = Utils.convertTimeToMinutes(slot.startTime);
        const bookedEndMinutes = Utils.convertTimeToMinutes(slot.endTime);

        // Only show if within business hours
        if (bookedEndMinutes <= startOfDay || bookedStartMinutes >= startOfDay + totalMinutes) {
          return;
        }

        // Adjust start/end to be within business hours if needed
        const adjustedStart = Math.max(bookedStartMinutes, startOfDay);
        const adjustedEnd = Math.min(bookedEndMinutes, startOfDay + totalMinutes);

        // Calculate position and width as percentages
        const startPercentage = ((adjustedStart - startOfDay) / totalMinutes) * 100;
        const endPercentage = ((adjustedEnd - startOfDay) / totalMinutes) * 100;
        const width = endPercentage - startPercentage;

        // Create and position the indicator
        const bookedSegment = document.createElement('div');
        bookedSegment.className = 'time-booked-segment';
        bookedSegment.style.left = `${startPercentage}%`;
        bookedSegment.style.width = `${width}%`;

        timeBooked.appendChild(bookedSegment);
      });
    },

    updateTimeSelectionVisualization: (startTime, endTime) => {
      if (!startTime || !endTime) return;

      const startMinutes = Utils.convertTimeToMinutes(startTime);
      const endMinutes = Utils.convertTimeToMinutes(endTime);

      if (startMinutes >= endMinutes) return;

      // Get the visualization container
      const timeVisualization = document.querySelector('.time-visualization');
      if (!timeVisualization) return;

      // Get or create the selection bar
      let timeSelection = timeVisualization.querySelector('.time-selection');
      if (!timeSelection) {
        timeSelection = document.createElement('div');
        timeSelection.className = 'time-selection';
        timeVisualization.appendChild(timeSelection);
      }

      // Calculate the total minutes in the day
      const startOfDay = CONFIG.businessHours.start * 60; // 9 AM in minutes
      const totalMinutes = (CONFIG.businessHours.end - CONFIG.businessHours.start) * 60;

      // Calculate position and width as percentages
      const startPercentage = ((startMinutes - startOfDay) / totalMinutes) * 100;
      const endPercentage = ((endMinutes - startOfDay) / totalMinutes) * 100;
      const width = endPercentage - startPercentage;

      // Update the selection bar
      timeSelection.style.display = 'block';
      timeSelection.style.left = `${startPercentage}%`;
      timeSelection.style.width = `${width}%`;
    }
  };

  // Function to handle the welcome banner
  function setupWelcomeBanner() {
    let welcomeBanner = document.getElementById('welcome-banner');
    if (!welcomeBanner) {
      welcomeBanner = document.createElement('div');
      welcomeBanner.id = 'welcome-banner';
      welcomeBanner.className = 'welcome-banner';

      const mainContent = document.querySelector('.main-content');
      if (mainContent) {
        mainContent.insertBefore(welcomeBanner, mainContent.firstChild);
      } else {
        document.body.insertBefore(welcomeBanner, document.body.firstChild);
      }
    }

    const mode = AppState.getUserMode();

    if (AppState.isAdmin) {
      welcomeBanner.innerHTML = `
      <div class="banner-content admin-banner">
        <i class="fas fa-shield-alt"></i>
        <span>Admin Mode - Managing All Bookings</span>
      </div>
    `;
      welcomeBanner.style.display = 'block';
    } else if (AppState.hasUserEmail()) {
      welcomeBanner.innerHTML = `
      <div class="banner-content user-banner">
        <i class="fas fa-user"></i>
        <span>Welcome, ${AppState.userEmail}</span>
      </div>
    `;
      welcomeBanner.style.display = 'block';
    } else {
      welcomeBanner.innerHTML = `
      <div class="banner-content guest-banner">
        <i class="fas fa-user-secret"></i>
        <span>Guest Mode - Bookings stored locally</span>
      </div>
    `;
      welcomeBanner.style.display = 'block';
    }
  }

  // Add CSS styles for mode indicators
  const modeStyles = document.createElement('style');
  modeStyles.textContent = `
  .guest-banner {
    background-color: #f3f4f6 !important;
    color: #6b7280 !important;
  }
  
  .guest-info {
    color: #6b7280;
    font-style: italic;
  }
  
  .guest-info i {
    color: #9ca3af;
  }
  
  .admin-info {
    color: #7c3aed;
    font-size: 0.875rem;
  }
  
  .admin-info i {
    color: #8b5cf6;
  }
`;
  document.head.appendChild(modeStyles);

  // ===== IMAGE CAROUSEL MODULE WITH SWIPE SUPPORT =====
  const ImageCarousel = {
    currentIndex: 0,
    images: [],
    resourceName: '',
    // Swipe properties
    startX: 0,
    currentX: 0,
    isDragging: false,
    threshold: 50, // Minimum distance for swipe

    /**
     * Open carousel with resource images
     * @param {Object} resource - Resource object with carouselImages array
     */
    open: function (resource) {
      if (!resource.carouselImages || resource.carouselImages.length === 0) {
        console.warn('No carousel images found for resource');
        return;
      }

      this.images = resource.carouselImages;
      this.resourceName = resource.name;
      this.currentIndex = 0;

      // Update modal title
      const carouselTitle = DOM.byId('carousel-title');
      if (carouselTitle) {
        carouselTitle.textContent = `${this.resourceName} - Images`;
      }

      // Generate images
      this.generateImages();

      // Generate indicators
      this.generateIndicators();

      // Setup swipe listeners
      this.setupSwipeListeners();

      // Update display
      this.updateDisplay();

      // Show modal
      const modal = DOM.byId('image-carousel-modal');
      if (modal) {
        DOM.addClass(modal, 'active');
        document.body.style.overflow = 'hidden';
      }
    },

    /**
     * Close carousel modal
     */
    hide: function () {
      const modal = DOM.byId('image-carousel-modal');
      if (modal) {
        DOM.removeClass(modal, 'active');
        document.body.style.overflow = '';
      }

      // Remove swipe listeners
      this.removeSwipeListeners();
    },

    /**
     * Generate image elements
     */
    generateImages: function () {
      const container = DOM.byId('carousel-images');
      if (!container) return;

      container.innerHTML = '';

      this.images.forEach((imageUrl, index) => {
        const img = document.createElement('img');
        img.className = 'carousel-image';
        img.src = imageUrl; // Use the URL as-is
        img.alt = `${this.resourceName} - Image ${index + 1}`;
        img.loading = index === 0 ? 'eager' : 'lazy';
        img.draggable = false; // Prevent default image dragging

        container.appendChild(img);
      });
    },

    /**
     * Generate indicator dots
     */
    generateIndicators: function () {
      const container = DOM.byId('carousel-indicators');
      if (!container) return;

      container.innerHTML = '';

      this.images.forEach((_, index) => {
        const indicator = document.createElement('div');
        indicator.className = 'carousel-indicator';
        if (index === 0) {
          DOM.addClass(indicator, 'active');
        }

        indicator.addEventListener('click', () => {
          this.goToSlide(index);
        });

        container.appendChild(indicator);
      });
    },

    /**
     * Navigate to specific slide
     * @param {number} index - Target slide index
     */
    goToSlide: function (index) {
      if (index < 0 || index >= this.images.length) return;

      this.currentIndex = index;
      this.updateDisplay();
    },

    /**
     * Navigate to previous slide
     */
    prevSlide: function () {
      const newIndex = this.currentIndex > 0 ? this.currentIndex - 1 : this.images.length - 1;
      this.goToSlide(newIndex);
    },

    /**
     * Navigate to next slide
     */
    nextSlide: function () {
      const newIndex = this.currentIndex < this.images.length - 1 ? this.currentIndex + 1 : 0;
      this.goToSlide(newIndex);
    },

    /**
     * Update carousel display based on current index
     */
    updateDisplay: function () {
      // Update images transform
      const imagesContainer = DOM.byId('carousel-images');
      if (imagesContainer) {
        const translateX = -this.currentIndex * 100;
        imagesContainer.style.transform = `translateX(${translateX}%)`;
      }

      // Update indicators
      const indicators = document.querySelectorAll('.carousel-indicator');
      indicators.forEach((indicator, index) => {
        if (index === this.currentIndex) {
          DOM.addClass(indicator, 'active');
        } else {
          DOM.removeClass(indicator, 'active');
        }
      });

      // Update counter
      const counter = DOM.byId('carousel-counter');
      if (counter) {
        counter.textContent = `${this.currentIndex + 1} / ${this.images.length}`;
      }
    },

    /**
     * Setup swipe/touch listeners
     */
    setupSwipeListeners: function () {
      const container = DOM.byId('carousel-images');
      if (!container) return;

      // Touch events
      container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
      container.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
      container.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });

      // Mouse events for desktop
      container.addEventListener('mousedown', this.handleMouseDown.bind(this));
      container.addEventListener('mousemove', this.handleMouseMove.bind(this));
      container.addEventListener('mouseup', this.handleMouseUp.bind(this));
      container.addEventListener('mouseleave', this.handleMouseUp.bind(this));
    },

    /**
     * Remove swipe listeners
     */
    removeSwipeListeners: function () {
      const container = DOM.byId('carousel-images');
      if (!container) return;

      container.removeEventListener('touchstart', this.handleTouchStart.bind(this));
      container.removeEventListener('touchmove', this.handleTouchMove.bind(this));
      container.removeEventListener('touchend', this.handleTouchEnd.bind(this));
      container.removeEventListener('mousedown', this.handleMouseDown.bind(this));
      container.removeEventListener('mousemove', this.handleMouseMove.bind(this));
      container.removeEventListener('mouseup', this.handleMouseUp.bind(this));
      container.removeEventListener('mouseleave', this.handleMouseUp.bind(this));
    },

    /**
     * Touch start handler
     */
    handleTouchStart: function (e) {
      this.startX = e.touches[0].clientX;
      this.isDragging = true;
    },

    /**
     * Touch move handler
     */
    handleTouchMove: function (e) {
      if (!this.isDragging) return;

      e.preventDefault(); // Prevent scrolling
      this.currentX = e.touches[0].clientX;
    },

    /**
     * Touch end handler
     */
    handleTouchEnd: function (e) {
      if (!this.isDragging) return;

      this.isDragging = false;
      this.handleSwipe();
    },

    /**
     * Mouse down handler
     */
    handleMouseDown: function (e) {
      this.startX = e.clientX;
      this.isDragging = true;
      e.preventDefault(); // Prevent text selection
    },

    /**
     * Mouse move handler
     */
    handleMouseMove: function (e) {
      if (!this.isDragging) return;

      this.currentX = e.clientX;
    },

    /**
     * Mouse up handler
     */
    handleMouseUp: function (e) {
      if (!this.isDragging) return;

      this.isDragging = false;
      this.handleSwipe();
    },

    /**
     * Handle swipe logic
     */
    handleSwipe: function () {
      const deltaX = this.currentX - this.startX;

      if (Math.abs(deltaX) > this.threshold) {
        if (deltaX > 0) {
          // Swiped right - go to previous slide
          this.prevSlide();
        } else {
          // Swiped left - go to next slide
          this.nextSlide();
        }
      }

      // Reset values
      this.startX = 0;
      this.currentX = 0;
    },

    /**
     * Handle keyboard navigation
     * @param {KeyboardEvent} event - Keyboard event
     */
    handleKeyboard: function (event) {
      const modal = DOM.byId('image-carousel-modal');
      if (!modal || !modal.classList.contains('active')) return;

      switch (event.key) {
        case 'ArrowLeft':
          event.preventDefault();
          this.prevSlide();
          break;
        case 'ArrowRight':
          event.preventDefault();
          this.nextSlide();
          break;
        case 'Escape':
          event.preventDefault();
          this.hide();
          break;
      }
    }
  };

  // ===== SMOOTH DISCOUNT BANNER MODULE =====
  const DiscountBanner = {
    hideTimeout: null,

    /**
     * Show discount banner with confetti
     * @param {number} discountPercent - Discount percentage (e.g., 10 for 10%)
     */
    show: function (discountPercent) {
      const banner = DOM.byId('discount-banner');
      const discountAmount = DOM.byId('discount-amount');

      if (!banner || !discountAmount) return;

      // Clear any existing hide timeout
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }

      // Update discount percentage
      discountAmount.textContent = `${discountPercent}%`;

      // Remove hiding class if it exists
      DOM.removeClass(banner, 'hiding');

      // Show banner with smooth animation
      DOM.addClass(banner, 'show');
      document.body.classList.add('has-discount-banner');

      // Trigger confetti
      this.createConfetti(banner);

      // Auto-hide after 8 seconds
      this.hideTimeout = setTimeout(() => {
        this.hide();
      }, 8000);
    },

    /**
     * Hide discount banner smoothly
     */
    hide: function () {
      const banner = DOM.byId('discount-banner');
      if (!banner) return;

      // Clear timeout if called manually
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }

      // Add hiding class for smooth exit animation
      DOM.addClass(banner, 'hiding');
      DOM.removeClass(banner, 'show');

      // Remove from body class and completely hide after animation
      setTimeout(() => {
        document.body.classList.remove('has-discount-banner');
        DOM.removeClass(banner, 'hiding');
      }, 800); // Match the CSS transition duration
    },

    /**
     * Create confetti animation
     * @param {HTMLElement} container - Container element for confetti
     */
    createConfetti: function (container) {
      const confettiCount = 30;

      for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';

          // Random horizontal position
          confetti.style.left = Math.random() * 100 + '%';

          // Random animation delay
          confetti.style.animationDelay = Math.random() * 2 + 's';

          // Random animation duration
          confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';

          container.appendChild(confetti);

          // Remove confetti after animation
          setTimeout(() => {
            if (confetti.parentNode) {
              confetti.parentNode.removeChild(confetti);
            }
          }, 4000);
        }, i * 100); // Stagger the confetti creation
      }
    },

    /**
     * Check user discount and show banner if applicable
     */
    checkAndShow: function () {
      // Check if user has a discount
      if (AppState.userDiscount && AppState.userDiscount > 0) {
        console.log(`User has ${AppState.userDiscount}% discount - showing banner`);
        this.show(AppState.userDiscount);
      }
    }
  };

  // Add this to your existing setupWelcomeBanner function or create a new initialization function
  function setupDiscountBanner() {
    // Check for discount after user is initialized
    if (AppState.userDiscount && AppState.userDiscount > 0) {
      // Small delay to let the page load first
      setTimeout(() => {
        DiscountBanner.checkAndShow();
      }, 1000);
    }
  }

  // ===== LOADING SCREENS & INDICATORS =====

  // Add this to your existing Utils or create a new LoadingManager object
  const LoadingManager = {
    /**
     * Show full page loading screen
     * @param {string} title - Loading title
     * @param {string} message - Loading message
     */
    showFullPageLoader: (title = 'Processing', message = 'Please wait while we process your request...') => {
      // Check if loader already exists
      let loader = document.querySelector('.full-page-loader');

      // Create loader if it doesn't exist
      if (!loader) {
        loader = document.createElement('div');
        loader.className = 'full-page-loader';

        loader.innerHTML = `
        <div class="loader-content">
          <div class="loader-icon">
            <div class="loader-spinner"></div>
          </div>
          <h3 class="loader-title">${title}</h3>
          <p class="loader-message">${message}</p>
        </div>
      `;

        document.body.appendChild(loader);
      } else {
        // Update existing loader
        loader.querySelector('.loader-title').textContent = title;
        loader.querySelector('.loader-message').textContent = message;
      }

      // Show loader (delay to ensure DOM is updated)
      setTimeout(() => {
        loader.classList.add('active');
      }, 10);
    },

    /**
     * Hide full page loading screen
     */
    hideFullPageLoader: () => {
      const loader = document.querySelector('.full-page-loader');
      if (loader) {
        loader.classList.remove('active');
      }
    },

    /**
     * Show loading indicator in a button
     * @param {string|HTMLElement} buttonSelector - Button element or selector
     */
    showButtonLoader: (buttonSelector) => {
      const button = typeof buttonSelector === 'string'
        ? document.querySelector(buttonSelector)
        : buttonSelector;

      if (button) {
        // Save original text
        button.dataset.originalText = button.innerHTML;
        // Add loading class
        button.classList.add('btn-loader', 'loading');
        // Disable button
        button.disabled = true;
      }
    },

    /**
     * Hide loading indicator from a button
     * @param {string|HTMLElement} buttonSelector - Button element or selector
     */
    hideButtonLoader: (buttonSelector) => {
      const button = typeof buttonSelector === 'string'
        ? document.querySelector(buttonSelector)
        : buttonSelector;

      if (button) {
        // Remove loading class
        button.classList.remove('btn-loader', 'loading');
        // Restore original text
        if (button.dataset.originalText) {
          button.innerHTML = button.dataset.originalText;
        }
        // Enable button
        button.disabled = false;
      }
    },

    /**
     * Show loading indicator in a specific section
     * @param {string|HTMLElement} containerSelector - Container element or selector
     */
    showSectionLoader: (containerSelector) => {
      const container = typeof containerSelector === 'string'
        ? document.querySelector(containerSelector)
        : containerSelector;

      if (container) {
        // Add positioning class if not present
        container.classList.add('has-loader');

        // Check if loader already exists
        let loader = container.querySelector('.section-loader');

        // Create loader if it doesn't exist
        if (!loader) {
          loader = document.createElement('div');
          loader.className = 'section-loader';
          loader.innerHTML = '<div class="section-spinner"></div>';
          container.appendChild(loader);
        }

        // Show loader
        setTimeout(() => {
          loader.classList.add('active');
        }, 10);
      }
    },

    /**
     * Hide loading indicator from a section
     * @param {string|HTMLElement} containerSelector - Container element or selector
     */
    hideSectionLoader: (containerSelector) => {
      const container = typeof containerSelector === 'string'
        ? document.querySelector(containerSelector)
        : containerSelector;

      if (container) {
        const loader = container.querySelector('.section-loader');
        if (loader) {
          loader.classList.remove('active');
        }
      }
    },

    /**
     * Create skeleton loaders for content
     * @param {string|HTMLElement} containerSelector - Container element or selector
     * @param {string} type - Type of skeleton ('text', 'circle', 'rect')
     * @param {number} count - Number of skeleton items to create
     */
    showSkeletonLoader: (containerSelector, type = 'text', count = 1) => {
      const container = typeof containerSelector === 'string'
        ? document.querySelector(containerSelector)
        : containerSelector;

      if (container) {
        // Clear container
        container.innerHTML = '';

        // Create skeleton items
        for (let i = 0; i < count; i++) {
          const skeletonItem = document.createElement('div');
          skeletonItem.className = `skeleton-loader ${type === 'circle' ? 'skeleton-circle' : type === 'rect' ? 'skeleton-rect' : ''}`;

          // Add margin to separate items
          if (i < count - 1) {
            skeletonItem.style.marginBottom = '10px';
          }

          container.appendChild(skeletonItem);
        }
      }
    },

    /**
     * Remove skeleton loaders
     * @param {string|HTMLElement} containerSelector - Container element or selector
     */
    hideSkeletonLoader: (containerSelector) => {
      const container = typeof containerSelector === 'string'
        ? document.querySelector(containerSelector)
        : containerSelector;

      if (container) {
        // Remove all skeleton loaders
        const skeletons = container.querySelectorAll('.skeleton-loader');
        skeletons.forEach(skeleton => skeleton.remove());
      }
    }
  };

  // ===== BOOKING MODAL =====
  const BookingModal = {
    open: (resourceId) => {
      if (!resourceId) {
        console.error('Resource ID is required');
        return;
      }

      BookingModal.cleanupModalContent();


      // Reset AppState references when opening new booking
      AppState.resetReferences();

      // Generate a consistent booking reference for this sesasion
      const bookingRef = AppState.getBookingReference();
      console.log(`New booking session started with reference: ${bookingRef}`);

      AppState.currentResourceId = resourceId;
      const resource = resources.find(r => r.id === resourceId);

      if (!resource) {
        console.error('Resource not found:', resourceId);
        Toast.show('error', 'Resource not found');
        return;
      }

      // Reset modal state
      BookingModal.resetState();

      // Update modal title
      const modalTitle = DOM.byId('modal-title');
      if (modalTitle) {
        modalTitle.textContent = `Book ${resource.name}`;
      }

      // Show step 1
      BookingModal.hideAllSteps();
      const bookingStep1 = DOM.byId('booking-step-1');
      if (bookingStep1) {
        // Initialize modern booking interface
        BookingModal.initializeInterface();
        DOM.show(bookingStep1);
      }

      // Show modal
      const bookingModal = DOM.byId('booking-modal');
      if (bookingModal) {
        DOM.addClass(bookingModal, 'active');
        document.body.style.overflow = 'hidden';
      }
    },

    hide: () => {
      const bookingModal = DOM.byId('booking-modal');
      if (bookingModal) {
        DOM.removeClass(bookingModal, 'active');
        document.body.style.overflow = '';
      }

      BookingModal.cleanupModalContent();

      AppState.resetReferences();

      // Reset submission locks
      if (API.activeRequests) {
        // Clear any hanging requests
        for (const key in API.activeRequests) {
          if (key.startsWith('addBookingToBuffer_') || key.startsWith('addBookingToDatabase_') ||
            key.startsWith('verifyInstapayPayment_')) {
            delete API.activeRequests[key];
          }
        }
      }
    },

    cleanupModalContent: () => {
      const modalContent = document.querySelector('.modal-content');
      if (!modalContent) return;

      // Remove any dynamically created steps (receipt, identification forms, etc.)
      const dynamicSteps = modalContent.querySelectorAll('#booking-receipt-step, #fixed-identification-step');
      dynamicSteps.forEach(step => step.remove());

      // Remove any injected styles for receipts
      const injectedStyles = document.querySelectorAll('#receipt-styles, #partial-success-styles, #payment-instructions-styles');
      injectedStyles.forEach(style => style.remove());

      console.log('Modal content cleaned up');
    },

    resetState: () => {
      AppState.selectedDateValue = null;
      AppState.selectedTimeSlot = null;
      AppState.selectedPaymentMethod = null;
      AppState.uploadedFile = null;

      AppState.resetReferences();

      // Reset the time visualization
      const timeSelection = document.querySelector('.time-selection');
      if (timeSelection) {
        timeSelection.style.display = 'none';
        timeSelection.style.left = '0';
        timeSelection.style.width = '0';
      }

      // Reset booked segments
      const timeBooked = document.querySelector('.time-booked');
      if (timeBooked) {
        timeBooked.innerHTML = '';
      }

      // Reset time slots
      document.querySelectorAll('.time-slot').forEach(slot => {
        slot.classList.remove('selected', 'start-selected', 'end-selected', 'in-range');
      });

      // Reset selection summary
      const selectionSummary = DOM.byId('selection-summary');
      if (selectionSummary) {
        DOM.hide(selectionSummary);
      }

      // Disable action buttons
      const continueButton = DOM.byId('continue-to-payment');
      if (continueButton) {
        continueButton.disabled = true;
      }

      const proceedButton = DOM.byId('proceed-to-payment');
      if (proceedButton) {
        proceedButton.disabled = true;
      }

      const verifyButton = DOM.byId('verify-payment');
      if (verifyButton) {
        verifyButton.disabled = true;
      }

      // Reset file upload if present
      const fileInput = DOM.byId('payment-screenshot');
      if (fileInput) {
        fileInput.value = '';
      }

      // Reset file preview
      const filePreview = DOM.byId('file-preview');
      const uploadInstructions = DOM.byId('upload-instructions');
      if (filePreview && uploadInstructions) {
        DOM.hide(filePreview);
        DOM.show(uploadInstructions);
      }

      // Reset verification status if present
      const verificationStatus = DOM.byId('verification-status');
      if (verificationStatus) {
        DOM.hide(verificationStatus);
      }

      // Hide confirmation button
      const confirmationAction = DOM.byId('confirmation-action');
      if (confirmationAction) {
        DOM.hide(confirmationAction);
      }

      // Show action buttons if they were hidden
      const actionButtons = DOM.byId('verify-payment')?.parentNode;
      if (actionButtons) {
        DOM.show(actionButtons, 'flex');
      }
    },


    hideAllSteps: () => {
      const steps = [
        DOM.byId('booking-step-1'),
        DOM.byId('booking-step-2'),
        DOM.byId('booking-step-3'),
        DOM.byId('booking-step-4'),
        DOM.byId('booking-step-5')
      ];

      steps.forEach(step => {
        if (step) {
          DOM.hide(step);
        }
      });
    },

    initializeInterface: () => {
      // Clean up any existing time visualization first
      const existingTimeVis = document.querySelector('.time-visualization');
      if (existingTimeVis) {
        existingTimeVis.remove();
      }

      // Initialize date selection
      BookingModal.initializeDateSelection();

      // Initialize time slots
      BookingModal.initializeTimeSlots();
    },

    initializeDateSelection: () => {
      const dateButtons = DOM.byId('date-buttons');
      if (!dateButtons) return;

      dateButtons.innerHTML = '';

      const today = new Date();
      const daysToShow = 14;

      for (let i = 0; i < daysToShow; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + i);

        const dateButton = document.createElement('button');
        dateButton.className = 'date-button ' + (i === 0 ? 'selected' : '');
        dateButton.dataset.date = date.toISOString().split('T')[0];

        const month = date.toLocaleDateString('en-US', { month: 'short' }).toUpperCase();
        const day = date.getDate();
        const weekday = date.toLocaleDateString('en-US', { weekday: 'short' });

        dateButton.innerHTML = `
        <span class="date-month">${month}</span>
        <span class="date-day">${day}</span>
        <span class="date-weekday">${weekday}</span>
      `;

        dateButton.addEventListener('click', () => {
          document.querySelectorAll('.date-button').forEach(btn => {
            DOM.removeClass(btn, 'selected');
          });

          DOM.addClass(dateButton, 'selected');
          AppState.selectedDateValue = dateButton.dataset.date;

          // Update available time slots based on selected date
          BookingModal.updateAvailableTimeSlots();
        });

        dateButtons.appendChild(dateButton);
      }

      // Set initial selected date
      AppState.selectedDateValue = today.toISOString().split('T')[0];

      // Setup carousel navigation
      const prevBtn = DOM.byId('date-prev');
      const nextBtn = DOM.byId('date-next');

      if (prevBtn && nextBtn) {
        prevBtn.addEventListener('click', () => {
          dateButtons.scrollBy({ left: -300, behavior: 'smooth' });
        });

        nextBtn.addEventListener('click', () => {
          dateButtons.scrollBy({ left: 300, behavior: 'smooth' });
        });
      }
    },

    initializeTimeSlots: () => {
      const timeSlotsContainer = DOM.byId('time-slots');
      if (!timeSlotsContainer) return;

      timeSlotsContainer.innerHTML = '';

      // Business hours from CONFIG
      const startHour = CONFIG.businessHours.start; // 9:00 AM
      const endHour = CONFIG.businessHours.end;     // 23:00 (11:00 PM)

      // Slot selection state
      let selectionStart = null;
      let selectionEnd = null;

      // Generate time slots in 30-minute increments
      // Important: Loop should run all the way to endHour (including the final hour)
      for (let hour = startHour; hour <= endHour; hour++) {
        // Create slot for the hour (XX:00)
        if (hour <= endHour) { // Only create hour slot if not the end hour
          const hourTimeString = `${hour.toString().padStart(2, '0')}:00`;
          const hourDisplayTime = Utils.formatTime(hourTimeString);

          const hourSlot = document.createElement('div');
          hourSlot.className = 'time-slot';
          hourSlot.dataset.time = hourTimeString;
          hourSlot.textContent = hourDisplayTime;

          // Add the hour slot
          timeSlotsContainer.appendChild(hourSlot);
        }

        // Create slot for the half hour (XX:30) if it's not the end hour
        if (hour < endHour) {
          const halfHourTimeString = `${hour.toString().padStart(2, '0')}:30`;
          const halfHourDisplayTime = Utils.formatTime(halfHourTimeString);

          const halfHourSlot = document.createElement('div');
          halfHourSlot.className = 'time-slot half-hour-slot';
          halfHourSlot.dataset.time = halfHourTimeString;
          halfHourSlot.textContent = halfHourDisplayTime;

          // Add the half hour slot
          timeSlotsContainer.appendChild(halfHourSlot);
        }
      }

      // Add click handlers to all time slots
      document.querySelectorAll('.time-slot').forEach(slot => {
        slot.addEventListener('click', function () {
          if (this.classList.contains('booked')) return;

          // Reset selection if clicking a new slot without a start
          if (!selectionStart) {
            // Clear all selections
            document.querySelectorAll('.time-slot').forEach(s => {
              s.classList.remove('start-selected', 'end-selected', 'in-range', 'selected');
            });

            // Reset time visualization
            const timeSelection = document.querySelector('.time-selection');
            if (timeSelection) {
              timeSelection.style.display = 'none';
            }

            // Set as start time
            selectionStart = this.dataset.time;
            this.classList.add('start-selected');
          }
          // If we have a start but no end
          else if (selectionStart && !selectionEnd) {
            const startTime = Utils.convertTimeToMinutes(selectionStart);
            const currentTime = Utils.convertTimeToMinutes(this.dataset.time);

            // Ensure end time is after start time
            if (currentTime <= startTime) {
              // Clicked on or before start time - reset and set as new start
              document.querySelectorAll('.time-slot').forEach(s => {
                s.classList.remove('start-selected', 'end-selected', 'in-range', 'selected');
              });

              selectionStart = this.dataset.time;
              selectionEnd = null;
              this.classList.add('start-selected');
              return;
            }

            // Check if there's any booked slot between start and current
            const hasBookedInRange = Array.from(document.querySelectorAll('.time-slot.booked')).some(slot => {
              const slotTime = Utils.convertTimeToMinutes(slot.dataset.time);
              return slotTime > startTime && slotTime < currentTime;
            });

            if (hasBookedInRange) {
              Toast.show('error', 'Cannot select a range that includes booked slots');
              return;
            }

            // Set as end time
            selectionEnd = this.dataset.time;
            this.classList.add('end-selected');

            // Mark all slots in between
            document.querySelectorAll('.time-slot').forEach(s => {
              const slotTime = Utils.convertTimeToMinutes(s.dataset.time);
              if (slotTime > startTime && slotTime < currentTime) {
                s.classList.add('in-range');
              }
            });

            // Create selected time slot object
            const resource = resources.find(r => r.id === AppState.currentResourceId);
            if (resource) {
              const startTime = selectionStart;
              const endTime = selectionEnd;

              // Calculate duration in hours
              const startMinutes = Utils.convertTimeToMinutes(startTime);
              const endMinutes = Utils.convertTimeToMinutes(endTime);
              const durationHours = (endMinutes - startMinutes) / 60;
              const durationFormatted = Utils.formatDuration(durationHours);

              // Calculate price
              const pricePerHour = resource.pricePerHour;
              const price = durationHours * pricePerHour;

              AppState.selectedTimeSlot = {
                date: AppState.selectedDateValue,
                startTime: startTime,
                endTime: endTime,
                duration: durationHours,
                durationFormatted: durationFormatted,
                price: price
              };

              // Update selection summary
              BookingModal.updateSelectionSummary();

              // Enable continue button
              const continueButton = DOM.byId('continue-to-payment');
              if (continueButton) continueButton.disabled = false;

              // Update time visualization
              UI.updateTimeSelectionVisualization(startTime, endTime);
            }
          }
          // If we have both start and end (complete selection)
          else {
            // Reset selection
            document.querySelectorAll('.time-slot').forEach(s => {
              s.classList.remove('start-selected', 'end-selected', 'in-range', 'selected');
            });

            selectionStart = this.dataset.time;
            selectionEnd = null;
            this.classList.add('start-selected');

            // Hide selection summary when starting a new selection
            const selectionSummary = DOM.byId('selection-summary');
            if (selectionSummary) DOM.hide(selectionSummary);

            // Disable continue button
            const continueButton = DOM.byId('continue-to-payment');
            if (continueButton) continueButton.disabled = true;

            // Clear time visualization
            const timeSelection = document.querySelector('.time-selection');
            if (timeSelection) timeSelection.style.display = 'none';

            // Reset selected time slot
            AppState.selectedTimeSlot = null;
          }
        });
      });

      // Create and add new time visualization
      const timeVisElement = DOM.byId('time-visualization');
      if (timeVisElement) {
        timeVisElement.innerHTML = ''; // Clear any existing content
        const visualization = UI.createTimeVisualization();
        timeVisElement.appendChild(visualization);
      }

      // Add change button event listener
      const changeSelectionButton = DOM.byId('change-selection');
      if (changeSelectionButton) {
        changeSelectionButton.addEventListener('click', () => {
          // Reset selection
          document.querySelectorAll('.time-slot').forEach(s => {
            s.classList.remove('start-selected', 'end-selected', 'in-range', 'selected');
          });

          selectionStart = null;
          selectionEnd = null;

          // Hide selection summary
          const selectionSummary = DOM.byId('selection-summary');
          if (selectionSummary) DOM.hide(selectionSummary);

          // Disable continue button
          const continueButton = DOM.byId('continue-to-payment');
          if (continueButton) continueButton.disabled = true;

          // Clear time visualization
          const timeSelection = document.querySelector('.time-selection');
          if (timeSelection) timeSelection.style.display = 'none';

          // Reset selected time slot
          AppState.selectedTimeSlot = null;
        });
      }

      // Initial update of available slots
      BookingModal.updateAvailableTimeSlots();
    },

    updateAvailableTimeSlots: () => {
      if (!AppState.selectedDateValue || !AppState.currentResourceId) return;

      // Get booked slots for the selected resource and date
      const resourceBookedSlots = bookedSlots.filter(slot =>
        slot.resourceId === AppState.currentResourceId &&
        slot.date === AppState.selectedDateValue
      );

      // Reset all slots to available
      document.querySelectorAll('.time-slot').forEach(slot => {
        DOM.removeClass(slot, 'booked');
        DOM.removeClass(slot, 'start-selected');
        DOM.removeClass(slot, 'end-selected');
        DOM.removeClass(slot, 'in-range');
        DOM.removeClass(slot, 'selected');
      });

      // Mark booked time slots
      resourceBookedSlots.forEach(bookedSlot => {
        const bookedStartMinutes = Utils.convertTimeToMinutes(bookedSlot.startTime);
        const bookedEndMinutes = Utils.convertTimeToMinutes(bookedSlot.endTime);

        document.querySelectorAll('.time-slot').forEach(slot => {
          const slotMinutes = Utils.convertTimeToMinutes(slot.dataset.time);
          const slotEndMinutes = slotMinutes + 30; // Each slot represents 30 minutes

          // Mark as booked if the slot overlaps with a booked time range
          // This is a more complex check for 30-minute slots
          if ((slotMinutes >= bookedStartMinutes && slotMinutes < bookedEndMinutes) ||
            (slotEndMinutes > bookedStartMinutes && slotEndMinutes <= bookedEndMinutes) ||
            (slotMinutes <= bookedStartMinutes && slotEndMinutes >= bookedEndMinutes)) {
            DOM.addClass(slot, 'booked');
          }
        });
      });

      // Update the time visualization
      UI.updateTimeVisualization(resourceBookedSlots);

      // Reset selection
      AppState.selectedTimeSlot = null;

      // Hide selection summary
      const selectionSummary = DOM.byId('selection-summary');
      if (selectionSummary) DOM.hide(selectionSummary);

      // Disable continue button
      const continueButton = DOM.byId('continue-to-payment');
      if (continueButton) {
        continueButton.disabled = true;
      }
    },

    updateSelectionSummary: () => {
      if (!AppState.selectedTimeSlot) return;

      // Show selection summary
      const selectionSummary = DOM.byId('selection-summary');
      if (selectionSummary) {
        const selectedDate = DOM.byId('selected-date');
        const selectedTime = DOM.byId('selected-time');

        if (selectedDate && selectedTime) {
          const dateObj = new Date(AppState.selectedTimeSlot.date);
          const formattedDate = dateObj.toLocaleDateString('en-US', {
            weekday: 'long',
            month: 'long',
            day: 'numeric'
          });

          selectedDate.querySelector('span').textContent = formattedDate;
          selectedTime.querySelector('span').textContent = `${Utils.formatTime(AppState.selectedTimeSlot.startTime)} - ${Utils.formatTime(AppState.selectedTimeSlot.endTime)} (${AppState.selectedTimeSlot.durationFormatted})`;

          DOM.show(selectionSummary);
        }
      }
    },

    goToPaymentSelection: () => {
      if (!AppState.selectedTimeSlot) {
        Toast.show('error', 'Please select a time slot');
        return;
      }

      // Update booking summary
      BookingModal.updateBookingSummary();

      // Generate payment methods
      BookingModal.generatePaymentMethods();

      // Show step 2
      BookingModal.hideAllSteps();
      DOM.show(DOM.byId('booking-step-2'));
    },

    // Add after line 1069 (after the closing bracket of goToPaymentSelection)
    // continueToPayment: () => {
    //   if (!AppState.selectedTimeSlot) {
    //     Toast.show('error', 'Please select a time slot');
    //     return;
    //   }

    //   // Show identification form first instead of directly going to payment
    //   BookingModal.showUserIdentificationForm();
    // },

    continueToPayment: () => {
      if (!AppState.selectedTimeSlot) {
        Toast.show('error', 'Please select a time slot');
        return;
      }

      console.log("Continue to payment called");

      // CONDITION 1: Skip form entirely if user email exists and not admin
      if (!AppState.isAdmin && AppState.hasUserEmail()) {
        console.log("User email already provided, skipping form:", AppState.userEmail);
        // Go directly to payment selection
        BookingModal.goToPaymentSelection();
        return;
      }

      // Hide all existing steps
      BookingModal.hideAllSteps();

      // Create a new custom identification form with vanilla JS
      const stepDiv = document.createElement('div');
      stepDiv.id = 'fixed-identification-step';
      stepDiv.className = 'booking-step';
      stepDiv.style.display = 'block';

      // CONDITION 2: Different form for admin vs regular user
      if (AppState.isAdmin) {
        console.log("Admin mode detected, showing user selection form");

        // Create admin version with user selection dropdown
        stepDiv.innerHTML = `
      <div class="step-header">
        <h3>Select or Add User</h3>
        <p>Choose an existing user or add a new one for this booking.</p>
      </div>
      
      <div class="user-selection-container">
        <div class="user-selection-toggle">
          <button id="existing-user-toggle" class="toggle-btn active">Existing User</button>
          <button id="new-user-toggle" class="toggle-btn">New User</button>
        </div>
        
        <div id="existing-user-form" class="user-form">
          <div class="form-group">
            <label for="fixed-email-select">User Email</label>
            <div class="autocomplete-container">
              <input type="email" id="fixed-email-select" class="form-control" placeholder="Search by email..." required>
              <div id="autocomplete-results" class="autocomplete-results"></div>
            </div>
          </div>
          
          <div class="user-details-preview">
            <div class="form-group">
              <label>Name</label>
              <p id="preview-name" class="form-preview">-</p>
            </div>
            <div class="form-group">
              <label>Phone</label>
              <p id="preview-phone" class="form-preview">-</p>
            </div>
            <div class="form-group">
              <label>Discount</label>
              <p id="preview-discount" class="form-preview">-</p>
            </div>
          </div>
        </div>
        
        <div id="new-user-form" class="user-form" style="display:none;">
          <div class="form-group">
            <label for="fixed-new-email">Email</label>
            <input type="email" id="fixed-new-email" class="form-control" placeholder="user@example.com" required>
          </div>
          <div class="form-group">
            <label for="fixed-new-name">Name</label>
            <input type="text" id="fixed-new-name" class="form-control" placeholder="Full Name" required>
          </div>
          <div class="form-group">
            <label for="fixed-new-phone">Phone</label>
            <input type="tel" id="fixed-new-phone" class="form-control" placeholder="+20 xxx xxx xxxx" required>
          </div>
          <div class="form-group">
            <label for="fixed-new-discount">Discount (%)</label>
            <input type="number" id="fixed-new-discount" class="form-control" placeholder="0" min="0" max="100" value="0">
          </div>
        </div>
      </div>
    `;
      } else {
        // Regular user version - simpler form
        stepDiv.innerHTML = `
      <div class="step-header">
        <h3>Your Information</h3>
        <p>Please provide your contact details for this booking.</p>
      </div>
      
      <div class="user-form">
        <div class="form-group">
          <label for="fixed-email">Email</label>
          <input type="email" id="fixed-email" class="form-control" placeholder="your@email.com" required>
        </div>
        <div class="form-group">
          <label for="fixed-name">Full Name</label>
          <input type="text" id="fixed-name" class="form-control" placeholder="Your Name" required>
        </div>
        <div class="form-group">
          <label for="fixed-phone">Phone Number</label>
          <input type="tel" id="fixed-phone" class="form-control" placeholder="+20 xxx xxx xxxx" required>
        </div>
      </div>
    `;
      }

      // Add action buttons for both admin and regular forms
      stepDiv.innerHTML += `
    <div class="form-actions">
      <button id="fixed-back" class="btn btn-outline">Back</button>
      <button id="fixed-continue" class="btn btn-primary">Continue</button>
    </div>
  `;

      // Add to modal content
      const modalContent = document.querySelector('.modal-content');
      modalContent.appendChild(stepDiv);

      // Set up toggle functionality for admin form
      if (AppState.isAdmin) {
        const existingToggle = document.getElementById('existing-user-toggle');
        const newToggle = document.getElementById('new-user-toggle');
        const existingForm = document.getElementById('existing-user-form');
        const newForm = document.getElementById('new-user-form');

        if (existingToggle && newToggle && existingForm && newForm) {
          // Set up toggle buttons
          existingToggle.addEventListener('click', function () {
            existingToggle.classList.add('active');
            newToggle.classList.remove('active');
            existingForm.style.display = 'block';
            newForm.style.display = 'none';
          });

          newToggle.addEventListener('click', function () {
            newToggle.classList.add('active');
            existingToggle.classList.remove('active');
            newForm.style.display = 'block';
            existingForm.style.display = 'none';
          });

          // Set up autocomplete with user data
          const emailSelect = document.getElementById('fixed-email-select');
          const autocompleteResults = document.getElementById('autocomplete-results');
          const usersData = window.appUsers || []; // Default to empty array if no global variable

          if (emailSelect && autocompleteResults) {
            // Input event for real-time filtering
            emailSelect.addEventListener('input', function () {
              const value = this.value.toLowerCase();
              autocompleteResults.innerHTML = '';

              if (!value) {
                autocompleteResults.style.display = 'none';
                return;
              }

              // Filter users that match the input value
              const matches = usersData.filter(user =>
                user.email.toLowerCase().includes(value) ||
                (user.name && user.name.toLowerCase().includes(value))
              ).slice(0, 5); // Limit to 5 results

              if (matches.length > 0) {
                autocompleteResults.style.display = 'block';

                // Create result items
                matches.forEach(user => {
                  const item = document.createElement('div');
                  item.className = 'autocomplete-item';
                  item.innerHTML = `
                <div class="user-email">${user.email}</div>
                <div class="user-name">${user.name || ''}</div>
              `;

                  // Click on result to select user
                  item.addEventListener('click', function () {
                    emailSelect.value = user.email;

                    // Update preview
                    document.getElementById('preview-name').textContent = user.name || '-';
                    document.getElementById('preview-phone').textContent = user.phone || '-';
                    document.getElementById('preview-discount').textContent =
                      user.discount !== undefined ? `${user.discount}%` : '0%';

                    // Hide results
                    autocompleteResults.style.display = 'none';
                  });

                  autocompleteResults.appendChild(item);
                });
              } else {
                // No matches found
                const noResults = document.createElement('div');
                noResults.className = 'autocomplete-item';
                noResults.textContent = 'No matching users found';
                autocompleteResults.appendChild(noResults);
                autocompleteResults.style.display = 'block';
              }
            });

            // Close autocomplete when clicking outside
            document.addEventListener('click', function (e) {
              if (e.target !== emailSelect && !autocompleteResults.contains(e.target)) {
                autocompleteResults.style.display = 'none';
              }
            });

            // Initialize with first 5 users
            if (usersData.length > 0) {
              const initialUsers = usersData.slice(0, 5);

              initialUsers.forEach(user => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.innerHTML = `
              <div class="user-email">${user.email}</div>
              <div class="user-name">${user.name || ''}</div>
            `;

                item.addEventListener('click', function () {
                  emailSelect.value = user.email;
                  document.getElementById('preview-name').textContent = user.name || '-';
                  document.getElementById('preview-phone').textContent = user.phone || '-';
                  document.getElementById('preview-discount').textContent =
                    user.discount !== undefined ? `${user.discount}%` : '0%';
                  autocompleteResults.style.display = 'none';
                });

                autocompleteResults.appendChild(item);
              });

              // Show initial dropdown when field is focused
              emailSelect.addEventListener('focus', function () {
                if (autocompleteResults.children.length > 0) {
                  autocompleteResults.style.display = 'block';
                }
              });
            }
          }
        }
      }

      // Pre-fill regular user form if values exist
      if (!AppState.isAdmin) {
        if (AppState.userEmail) {
          const emailInput = document.getElementById('fixed-email');
          if (emailInput) emailInput.value = AppState.userEmail;
        }
        if (AppState.userName) {
          const nameInput = document.getElementById('fixed-name');
          if (nameInput) nameInput.value = AppState.userName;
        }
        if (AppState.userPhone) {
          const phoneInput = document.getElementById('fixed-phone');
          if (phoneInput) phoneInput.value = AppState.userPhone;
        }
      }

      // Add back button event listener
      const backButton = document.getElementById('fixed-back');
      if (backButton) {
        backButton.addEventListener('click', function () {
          // Clean up our custom step
          stepDiv.remove();

          // Show step 1 again
          const step1 = document.getElementById('booking-step-1');
          if (step1) step1.style.display = 'block';
        });
      }

      // Add continue button event listener
      const continueButton = document.getElementById('fixed-continue');
      if (continueButton) {
        continueButton.addEventListener('click', function () {
          // Clear any previous errors
          document.querySelectorAll('.error-message').forEach(el => el.remove());
          document.querySelectorAll('input').forEach(inp => inp.style.borderColor = '');

          let isValid = true;
          let userData = {};

          // Handle different validation based on user type and form mode
          if (AppState.isAdmin) {
            // Check which form is active
            const existingToggle = document.getElementById('existing-user-toggle');
            if (existingToggle && existingToggle.classList.contains('active')) {
              // Existing user form
              const emailInput = document.getElementById('fixed-email-select');
              const previewName = document.getElementById('preview-name');
              const previewPhone = document.getElementById('preview-phone');
              const previewDiscount = document.getElementById('preview-discount');

              if (!emailInput || !emailInput.value.trim()) {
                showInputError(emailInput, "Please select a user");
                isValid = false;
              } else {
                // Get discount as number
                let discount = 0;
                if (previewDiscount) {
                  const discountText = previewDiscount.textContent;
                  if (discountText && discountText !== '-') {
                    discount = parseInt(discountText);
                  }
                }

                userData = {
                  email: emailInput.value.trim(),
                  name: previewName ? previewName.textContent !== '-' ? previewName.textContent : '' : '',
                  phone: previewPhone ? previewPhone.textContent !== '-' ? previewPhone.textContent : '' : '',
                  discount: isNaN(discount) ? 0 : discount
                };
              }
            } else {
              // New user form
              const emailInput = document.getElementById('fixed-new-email');
              const nameInput = document.getElementById('fixed-new-name');
              const phoneInput = document.getElementById('fixed-new-phone');
              const discountInput = document.getElementById('fixed-new-discount');

              // Email validation
              if (!emailInput || !emailInput.value.trim()) {
                showInputError(emailInput, "Email is required");
                isValid = false;
              } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(emailInput.value.trim())) {
                showInputError(emailInput, "Please enter a valid email");
                isValid = false;
              }

              // Name validation
              if (!nameInput || !nameInput.value.trim()) {
                showInputError(nameInput, "Name is required");
                isValid = false;
              } else if (nameInput.value.trim().length < 2) {
                showInputError(nameInput, "Name must be at least 2 characters");
                isValid = false;
              }

              // Phone validation
              if (!phoneInput || !phoneInput.value.trim()) {
                showInputError(phoneInput, "Phone number is required");
                isValid = false;
              } else if (!/^\+?[\d\s-]{8,}$/.test(phoneInput.value.trim())) {
                showInputError(phoneInput, "Please enter a valid phone number");
                isValid = false;
              }

              if (isValid) {
                userData = {
                  email: emailInput.value.trim(),
                  name: nameInput.value.trim(),
                  phone: phoneInput.value.trim(),
                  discount: discountInput ? parseInt(discountInput.value || 0) : 0,
                  isNewUser: true
                };

                AppState

                // Add the new user to the global users array if it exists
                if (typeof window.addUser === 'function') {
                  window.addUser(userData);
                } else if (window.appUsers) {
                  // Fallback if addUser function doesn't exist
                  const existingIndex = window.appUsers.findIndex(u =>
                    u.email.toLowerCase() === userData.email.toLowerCase()
                  );

                  if (existingIndex >= 0) {
                    window.appUsers[existingIndex] = userData;
                  } else {
                    window.appUsers.push(userData);
                  }
                }
              }
            }
          } else {
            // Regular user form validation
            const emailInput = document.getElementById('fixed-email');
            const nameInput = document.getElementById('fixed-name');
            const phoneInput = document.getElementById('fixed-phone');

            // Email validation
            if (!emailInput || !emailInput.value.trim()) {
              showInputError(emailInput, "Email is required");
              isValid = false;
            } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(emailInput.value.trim())) {
              showInputError(emailInput, "Please enter a valid email");
              isValid = false;
            }

            // Name validation
            if (!nameInput || !nameInput.value.trim()) {
              showInputError(nameInput, "Name is required");
              isValid = false;
            } else if (nameInput.value.trim().length < 2) {
              showInputError(nameInput, "Name must be at least 2 characters");
              isValid = false;
            }

            // Phone validation
            if (!phoneInput || !phoneInput.value.trim()) {
              showInputError(phoneInput, "Phone number is required");
              isValid = false;
            } else if (!/^\+?[\d\s-]{8,}$/.test(phoneInput.value.trim())) {
              showInputError(phoneInput, "Please enter a valid phone number");
              isValid = false;
            }

            if (isValid) {
              userData = {
                email: emailInput.value.trim(),
                name: nameInput.value.trim(),
                phone: phoneInput.value.trim(),
                isNewUser: true
              };
            }
          }

          if (isValid) {
            console.log("Form validated successfully with values:", userData);

            // Update app state
            AppState.setUserDetails(userData);

            // Clean up our custom step
            stepDiv.remove();

            // Proceed to payment selection
            BookingModal.goToPaymentSelection();
          } else {
            console.log("Form validation failed");
          }
        });
      }

      // Helper function to show errors
      function showInputError(input, message) {
        if (!input) return;

        // Add red border
        input.style.borderColor = '#ef4444';

        // Create error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.style.color = '#ef4444';
        errorDiv.style.fontSize = '0.75rem';
        errorDiv.style.marginTop = '0.25rem';
        errorDiv.textContent = message;

        // Add error after input
        input.parentNode.appendChild(errorDiv);
      }
    },

    updateBookingSummary: () => {
      if (!AppState.selectedTimeSlot || !AppState.currentResourceId) return;

      const resource = resources.find(r => r.id === AppState.currentResourceId);
      if (!resource) return;

      // Update resource, date, time
      const summaryResource = DOM.byId('summary-resource');
      const summaryDate = DOM.byId('summary-date');
      const summaryTime = DOM.byId('summary-time');

      if (summaryResource && summaryDate && summaryTime) {
        summaryResource.textContent = resource.name;

        const dateObj = new Date(AppState.selectedTimeSlot.date);
        const formattedDate = dateObj.toLocaleDateString('en-US', {
          weekday: 'short',
          month: 'long',
          day: 'numeric'
        });
        summaryDate.textContent = formattedDate;

        summaryTime.textContent = `${Utils.formatTime(AppState.selectedTimeSlot.startTime)} - ${Utils.formatTime(AppState.selectedTimeSlot.endTime)} (${AppState.selectedTimeSlot.durationFormatted})`;
      }

      // Calculate price with any applicable discount
      const basePrice = AppState.selectedTimeSlot.price;
      const userDiscount = AppState.userDiscount || 0;
      const priceDetails = Utils.calculateBookingPrice(basePrice, userDiscount);

      // Store the calculated final price for later use
      AppState.selectedTimeSlot.finalPrice = priceDetails.finalPrice;

      // Find the amount element(s)
      const amountElements = document.querySelectorAll('.detail-item.summary-total');

      // Update each element found (usually just one)
      amountElements.forEach(element => {
        if (priceDetails.discountAmount > 0) {
          // If there's a discount, show all three lines
          element.innerHTML = `
        <div class="with-discount">
          <div class="price-row">
            <span class="price-label">Amount:</span>
            <span class="price-value">EGP ${priceDetails.originalPrice.toFixed(2)}</span>
          </div>
          <div class="discount-row">
            <span class="discount-label">Discount (${priceDetails.discountPercentage}%):</span>
            <span class="discount-value">-EGP ${priceDetails.discountAmount.toFixed(2)}</span>
          </div>
          <div class="net-price-row">
            <span class="net-price-label">Net Amount:</span>
            <span class="net-price-value">EGP ${priceDetails.finalPrice.toFixed(2)}</span>
          </div>
        </div>
      `;
        } else {
          // No discount, just show the net amount line
          element.innerHTML = `
        <div>
          <div class="net-price-row">
            <span class="net-price-label">Amount:</span>
            <span class="net-price-value">EGP ${priceDetails.finalPrice.toFixed(2)}</span>
          </div>
        </div>
      `;
        }
      });

      // Update payment button text if it exists
      const payButton = DOM.byId('process-card-payment');
      if (payButton) {
        payButton.textContent = `Pay EGP ${priceDetails.finalPrice.toFixed(2)}`;
      }

      // Update Instapay amount if it exists
      const instapayAmount = document.querySelector('.payment-details-grid .payment-value:first-child');
      if (instapayAmount) {
        instapayAmount.textContent = `EGP ${priceDetails.finalPrice.toFixed(2)}`;
      }

      // Update credit card payment amount if it exists
      const cardPaymentSummary = document.querySelector('.payment-detail .detail-value');
      if (cardPaymentSummary) {
        cardPaymentSummary.textContent = `EGP ${priceDetails.finalPrice.toFixed(2)}`;
      }
    },

    generatePaymentMethods: () => {
      const paymentMethodsContainer = DOM.byId('payment-methods');
      if (!paymentMethodsContainer) return;

      paymentMethodsContainer.innerHTML = '';

      paymentMethods.forEach(method => {
        const methodElement = document.createElement('div');
        methodElement.className = 'payment-method';
        methodElement.setAttribute('data-method', method.id);
        methodElement.setAttribute('data-type', method.type);

        methodElement.innerHTML = `
      <div class="payment-method-icon">
        <img src="${method.icon}" alt="${method.name}">
      </div>
      <div class="payment-method-details">
        <h4>${method.name}</h4>
        <p>${method.description}</p>
      </div>
    `;

        methodElement.addEventListener('click', () => {
          BookingModal.selectPaymentMethod(method.id);
        });

        paymentMethodsContainer.appendChild(methodElement);
      });
    },

    selectPaymentMethod: (methodId) => {
      AppState.selectedPaymentMethod = methodId;

      const paymentMethods = document.querySelectorAll('.payment-method');
      paymentMethods.forEach(method => {
        DOM.removeClass(method, 'selected');
      });

      const selectedMethod = document.querySelector(`.payment-method[data-method="${methodId}"]`);
      if (selectedMethod) {
        DOM.addClass(selectedMethod, 'selected');
      }

      const proceedButton = DOM.byId('proceed-to-payment');
      if (proceedButton) {
        proceedButton.disabled = false;
      }
    },

    proceedToPaymentDetails: () => {
      if (!AppState.selectedPaymentMethod) {
        Toast.show('error', 'Please select a payment method');
        return;
      }

      // Get the selected method from the array
      const selectedMethod = paymentMethods.find(method => method.id === AppState.selectedPaymentMethod);
      if (!selectedMethod) return;

      BookingModal.hideAllSteps();

      if (selectedMethod.id === 'instapay') {
        // Use consistent PAYMENT reference from AppState
        const paymentRefNum = DOM.byId('payment-ref-num');
        if (paymentRefNum) {
          paymentRefNum.textContent = AppState.getPaymentReference();
        }

        // Update payment details with current price
        BookingModal.updateInstapayPaymentDetails();

        DOM.show(DOM.byId('booking-step-3'));
      } else if (selectedMethod.id === 'credit-card') {
        const bookingStep4 = DOM.byId('booking-step-4');
        if (bookingStep4) {
          // Update pay button text with amount
          const payButton = DOM.byId('process-card-payment');
          if (payButton) {
            payButton.textContent = `Pay EGP ${AppState.selectedTimeSlot.price.toFixed(2)}`;
          }

          DOM.show(bookingStep4);
        }
      } else if (selectedMethod.id === 'cash') {
        // Handle cash payment - special flow
        // No verification needed, just confirm booking with cash flag
        BookingModal.processBookingWithCash();
      } else {
        // Other payment methods with external redirects
        const bookingStep5 = DOM.byId('booking-step-5');
        if (bookingStep5) {
          const methodLogo = DOM.byId('payment-method-logo');
          const methodTitle = DOM.byId('payment-method-title');
          const methodInstructions = DOM.byId('payment-method-instructions');

          if (methodLogo && methodTitle && methodInstructions) {
            methodLogo.src = selectedMethod.icon;
            methodTitle.textContent = `Pay with ${selectedMethod.name}`;
            methodInstructions.textContent =
              `You will be redirected to complete your payment. Please ensure you have the necessary app or credentials ready.`;
          }

          DOM.show(bookingStep5);
        }
      }
    },

    processBookingWithCash: () => {
      // Show loading screen
      LoadingManager.showFullPageLoader('Processing', 'Confirming your cash booking...');

      // Update AppState to indicate cash payment
      AppState.selectedPaymentMethod = 'cash';

      // Process the booking
      BookingModal.processBooking()
        .then(() => {
          LoadingManager.hideFullPageLoader();
        })
        .catch(error => {
          LoadingManager.hideFullPageLoader();
          console.error('Cash booking failed:', error);
          // Error handling already done in processBooking
        });
    },

    handleFileUpload: (event) => {
      // First clear any existing preview
      clearFilePreview();
      const file = event.target.files[0];
      if (!file) return;

      // Check file type
      const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'application/pdf'];
      if (!validTypes.includes(file.type)) {
        Toast.show('error', 'Please upload a valid image or PDF file');
        return;
      }

      // Check file size (5MB max)
      if (file.size > 5 * 1024 * 1024) {
        Toast.show('error', 'File size should be less than 5MB');
        return;
      }

      // Store the file
      AppState.uploadedFile = file;

      // Show preview
      const uploadInstructions = DOM.byId('upload-instructions');
      const previewContainer = DOM.byId('file-preview');
      const previewImage = DOM.byId('preview-image');

      if (uploadInstructions && previewContainer && previewImage) {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function (e) {
            previewImage.src = e.target.result;
            DOM.show(previewContainer);
            DOM.hide(uploadInstructions);
          };
          reader.readAsDataURL(file);
        } else {
          // PDF preview (just show an icon)
          previewImage.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjZTJlNWU3IiBkPSJNMTI4IDBoMjU2djUxMkgxMjh6Ii8+PHBhdGggZmlsbD0iI2Y1ZjZmNyIgZD0iTTM4NCA1MTJIMTkyVjBoMTkyeiIvPjxwYXRoIGZpbGw9IiNjZDIxMGIiIGQ9Ik00MTYgNTEySDk2VjI1NmgzMjB6Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTI1NiAzMzZjLTguODM3IDAtMTYtNy4xNjQtMTYtMTZoLTE2Yy0uMDIxIDguODM4IDMuMTYgMTcuNDQ2IDguOTE0IDI0LjE3MmE0OC4wOTYgNDguMDk2IDAgMCAxLTQuOTE0LTE1LjM2QzIxOS40MDYgMzY0LjIxMiAyNDEuNzk1IDM1MiAyNzIgMzUyYzkuMjIgMCAxNi0yLjc3OCAxNi04aDMyYy0uMDEgMTcuNDI4LTE0LjU4MiAzMS45NTYtMzIgMzEuOTctOS41ODYgMC0xNy44NzEtMy40MjYtMjQuNzMtOS4xMjhBMzEuODI0IDMxLjgyNCAwIDAgMCAyNTYgMzM2eiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0zMjggMzIwSDI3MnYtMzJoLTMydjMyaC01NnYzMmg1NnYzMmgzMnYtMzJoNTZ6Ii8+PC9zdmc+';
          DOM.show(previewContainer);
          DOM.hide(uploadInstructions);
        }
      }

      // Enable verify button
      const verifyButton = DOM.byId('verify-payment');
      if (verifyButton) {
        verifyButton.disabled = false;
      }
    },

    // Updates to BookingModal.verifyPayment function
    verifyPayment: () => {
      if (!AppState.uploadedFile) {
        Toast.show('error', 'Please upload a payment screenshot');
        return;
      }

      // Check if verification is already in progress
      const paymentRef = AppState.getPaymentReference();
      const verifyTrackingId = `verifyInstapayPayment_${paymentRef}`;

      if (API.activeRequests && API.activeRequests[verifyTrackingId]) {
        console.warn('Verification already in progress');
        Toast.show('info', 'Verification already in progress, please wait...');
        return;
      }

      // Show loading on button
      LoadingManager.showButtonLoader('#verify-payment');

      // Show verification section with loading
      const verificationStatus = DOM.byId('verification-status');
      if (verificationStatus) {
        DOM.show(verificationStatus);
        verificationStatus.innerHTML = `
      <div class="status-loading">
        <div class="loading-spinner"></div>
        <p>Verifying payment, please wait<span class="loading-dots"></span></p>
      </div>
    `;
      }

      // Get payment reference
      const paymentReference = AppState.getPaymentReference();

      // Get the expected amount - KEY CHANGE HERE
      // If we're verifying a second payment for a remaining amount, use that instead
      const expectedAmount = AppState.expectedRemainingAmount ||
        (AppState.selectedTimeSlot ?
          AppState.selectedTimeSlot.finalPrice || AppState.selectedTimeSlot.price : 0);

      console.log('Verifying payment with expected amount:', expectedAmount);
      console.log('Remaining amount in state:', AppState.expectedRemainingAmount);

      // Verification options
      const verificationOptions = {
        maxAgeMins: 10,
        strictMetadataCheck: false,
        allowMoreThanExpected: true
      };

      // Verify the payment
      API.verifyInstapayPayment(AppState.uploadedFile, paymentReference, expectedAmount, verificationOptions)
        .then(response => {
          let parsedComponents;

          try {
            // First, parse the response if it's still a string
            const initialParsed = typeof response === 'string' ? JSON.parse(response) : response;

            // Now, the response itself is a stringified JSON object containing the three components
            if (typeof initialParsed === 'string') {
              parsedComponents = JSON.parse(initialParsed);
            } else if (initialParsed && typeof initialParsed === 'object') {
              // Already an object, might be directly the components or wrapped in a property
              if (initialParsed.ocrResult && initialParsed.verificationResult) {
                // It's the direct components object
                parsedComponents = initialParsed;
              } else if (initialParsed.result && typeof initialParsed.result === 'string') {
                // It might be wrapped in a result property as a string
                parsedComponents = JSON.parse(initialParsed.result);
              } else {
                // As a last resort, try to find the components
                parsedComponents = {
                  ocrResult: initialParsed.ocrResult || initialParsed.result?.ocrResult || {},
                  verificationResult: initialParsed.verificationResult || initialParsed.result?.verificationResult || {},
                  decision: initialParsed.decision || initialParsed.result?.decision || {}
                };
              }
            } else {
              throw new Error('Unexpected response format');
            }

            console.log('Parsed components:', parsedComponents);
          } catch (error) {
            console.error('Error parsing components:', error, 'Raw response:', response);
            throw new Error('Failed to process the verification response. Please try again.');
          }

          // Extract the three objects from the parsed components
          const { ocrResult, verificationResult, decision } = parsedComponents;

          console.log('OCR Result:', ocrResult);
          console.log('Verification Result:', verificationResult);
          console.log('Decision:', decision);

          // Check if we have the necessary objects
          if (!ocrResult || !verificationResult) {
            throw new Error('Incomplete verification data returned from server.');
          }

          // Store verification details for later use
          AppState.verificationResult = {
            fileUrl: parsedComponents.fileUrl || '',
            verified: verificationResult.isLegitimate && verificationResult.isRightAmount,
            confidence: ocrResult.confidence?.amount
              ? `${(ocrResult.confidence.amount * 100).toFixed(1)}%`
              : 'Low',
            message: decision?.message || getVerificationMessage(verificationResult),
            remainder: verificationResult.remainder || 0,
            amountStatus: verificationResult.amountStatus || 'unknown',
            detailedResult: parsedComponents,
            decisionCode: decision?.primaryCode || null,
            decision: decision?.decision || null,
            timestamp: new Date().toISOString()
          };

          console.log('Stored verification result:', AppState.verificationResult);

          // Hide button loader
          LoadingManager.hideButtonLoader('#verify-payment');

          // IMPORTANT ADDITION: If we're checking for a remaining amount and it matches
          // then we need to adjust how we handle the workflow
          if (AppState.expectedRemainingAmount &&
            (decision?.decision === 'APPROVED' || verificationResult.isRightAmount)) {
            console.log('Remaining amount payment verified!');

            // Calculate the new total paid amount (original partial + this payment)
            const originalPartialAmount = AppState.partialPaymentAmount || 0;
            const thisPaymentAmount = parseFloat(ocrResult.receipt?.data?.amount || 0);
            const totalPaidNow = originalPartialAmount + thisPaymentAmount;

            console.log('Original partial amount:', originalPartialAmount);
            console.log('This payment amount:', thisPaymentAmount);
            console.log('Total paid now:', totalPaidNow);

            // Clear the remaining amount flag since it's now paid
            AppState.expectedRemainingAmount = 0;

            // Update the total amount in the AppState
            AppState.partialPaymentAmount = totalPaidNow;
            AppState.remainingAmount = 0;

            // Update the booking details
            if (AppState.selectedTimeSlot) {
              AppState.selectedTimeSlot.finalPrice = totalPaidNow;
              AppState.selectedTimeSlot.isPartialPayment = false;
            }

            // Show success for complete payment and proceed with booking
            showCompletePaymentSuccess(totalPaidNow);
            return;
          }

          // Update verification status UI based on result (standard flow)
          updateVerificationUI(verificationResult, ocrResult, decision);

          // For different result types, handle accordingly
          if (decision?.decision === 'APPROVED' ||
            (verificationResult.isLegitimate &&
              (verificationResult.isRightAmount || verificationResult.amountStatus === 'more'))) {

            // Show confirmation button
            const confirmationAction = DOM.byId('confirmation-action');
            if (confirmationAction) {
              DOM.show(confirmationAction);
            }

            // Hide action buttons
            const actionButtons = DOM.byId('verify-payment')?.parentNode;
            if (actionButtons) {
              DOM.hide(actionButtons);
            }

            // Process the booking
            BookingModal.handleVerifiedInstapayPayment();
          }
          else if (decision?.decision === 'PARTIAL' || verificationResult.amountStatus === 'less') {
            // Get the parsed amount from the receipt
            const paidAmount = parseFloat(ocrResult.receipt?.data?.amount || 0);
            const remainingAmount = Math.abs(verificationResult.remainder || 0);

            // Setup partial payment button with the actual amounts from the receipt
            setupPartialPaymentButton(paidAmount, remainingAmount);
          }
        })
        .catch(error => {
          // Handle error
          console.error('Error during verification:', error);

          // Hide button loader
          LoadingManager.hideButtonLoader('#verify-payment');

          // Show error in verification status with explicit "wrong photo" message
          if (verificationStatus) {
            verificationStatus.innerHTML = `
          <div class="status-error">
            <div class="status-error-header">
              <i class="fas fa-times-circle status-error-icon"></i>
              <h3 class="status-error-title">Verification Failed</h3>
            </div>
            <div class="status-error-details">
              <p>${error.message || 'This doesn\'t appear to be a valid Instapay receipt. Please upload a screenshot of your payment.'}</p>
              <div class="error-example">
                <p class="error-example-title">Please ensure:</p>
                <ul class="error-example-list">
                  <li>You've uploaded a screenshot of an Instapay payment receipt</li>
                  <li>The image is clear and not cropped</li>
                  <li>The payment amount and reference number are visible</li>
                  <li>The screenshot shows the full receipt</li>
                </ul>
              </div>
            </div>
          </div>
        `;
          }
        });
    },

    updateInstapayPaymentDetails: () => {
      if (!AppState.selectedTimeSlot) return;

      const finalPrice = AppState.selectedTimeSlot.finalPrice || AppState.selectedTimeSlot.price;

      // Find all payment labels and update amount
      const amountLabels = document.querySelectorAll('.payment-label');
      for (let i = 0; i < amountLabels.length; i++) {
        if (amountLabels[i].textContent.trim() === 'Amount:') {
          // Found the Amount label, now get the next element which should be the value
          const amountValue = amountLabels[i].nextElementSibling;
          if (amountValue && amountValue.classList.contains('payment-value')) {
            amountValue.textContent = `EGP ${finalPrice.toFixed(2)}`;
            break;
          }
        }
      }

      // Always use the consistent PAYMENT reference from AppState
      const refNumElement = document.getElementById('payment-ref-num');
      if (refNumElement) {
        refNumElement.textContent = AppState.getPaymentReference();
      }
    },

    processCardPayment: () => {
      // Show loading on button
      LoadingManager.showButtonLoader('#process-card-payment');

      // Simulate card payment processing
      setTimeout(() => {
        // Hide button loader
        LoadingManager.hideButtonLoader('#process-card-payment');

        // Process the booking
        BookingModal.processBooking()
          .catch(error => {
            console.error('Card payment booking failed:', error);
            // Error handling already done in processBooking
          });
      }, 1500);
    },

    continueToExternalPayment: () => {
      // Show loading on button
      LoadingManager.showButtonLoader('#continue-to-external');

      // Show toast for redirecting
      Toast.show('info', 'Redirecting to payment gateway...');

      // Simulate redirect and callback
      setTimeout(() => {
        // Show full page loader
        LoadingManager.showFullPageLoader('Processing Payment', 'Completing your payment...');

        // Process the booking
        BookingModal.processBooking()
          .then(() => {
            // Hide loaders
            LoadingManager.hideButtonLoader('#continue-to-external');
            LoadingManager.hideFullPageLoader();
          })
          .catch(error => {
            // Hide loaders
            LoadingManager.hideButtonLoader('#continue-to-external');
            LoadingManager.hideFullPageLoader();
            console.error('External payment booking failed:', error);
            // Error handling already done in processBooking
          });
      }, 1500);
    },

    handleVerifiedInstapayPayment: (isPartial = false) => {
      // Add attributes to indicate this is a partial payment if applicable
      if (isPartial) {
        // Update the booking details to reflect partial payment
        AppState.selectedTimeSlot.finalPrice = AppState.partialPaymentAmount || AppState.selectedTimeSlot.finalPrice;
        AppState.selectedTimeSlot.isPartialPayment = true;
        AppState.selectedTimeSlot.remainingAmount = AppState.remainingAmount || 0;

        // Show a note to the user about partial payment
        Toast.show('info', `Processing with partial payment of EGP ${AppState.partialPaymentAmount.toFixed(2)}`);
      }

      // Process the booking (verification result already in AppState)
      BookingModal.processBooking()
        .then(result => {
          console.log('InstaPay booking processed successfully:', result);

          // If this was a partial payment, show special confirmation
          if (isPartial) {
            // Show special partial payment success message
            showPartialPaymentSuccess(
              AppState.partialPaymentAmount,
              AppState.remainingAmount
            );
          }
        })
        .catch(error => {
          console.error('InstaPay booking failed after verification:', error);
          // Error handling already done in processBooking
        });
    },

    processBooking: () => {
      // Don't proceed if essential data is missing
      if (!AppState.selectedTimeSlot || !AppState.currentResourceId) {
        Toast.show('error', 'Invalid booking data');
        return Promise.reject(new Error('Invalid booking data'));
      }

      // Check if already submitting via API's own mechanisms
      // This is an extra safety check using BOOKING reference
      const bookingRef = AppState.getBookingReference();
      const bufferTrackingId = `addBookingToBuffer_${bookingRef}`;

      if (API.activeRequests && API.activeRequests[bufferTrackingId]) {
        console.warn('Booking already in progress, preventing duplicate submission');
        Toast.show('info', 'Your booking is already being processed, please wait...');
        return Promise.reject(new Error('Submission already in progress'));
      }

      // Debug info to trace references
      console.group('Booking Process');
      console.log('Booking Reference:', AppState.getBookingReference());
      console.log('Payment Reference:', AppState.getPaymentReference());
      console.log('API Active Requests:', API.activeRequests);
      console.groupEnd();

      try {
        // Step 1: Formulate the booking request with all necessary data
        const bookingRequest = formulateBookingRequest(AppState);

        // Step 2: Add payment-specific details if needed
        let finalBookingRequest = bookingRequest;

        if (AppState.selectedPaymentMethod === 'instapay' && AppState.verificationResult) {
          finalBookingRequest = addPaymentDetailsToRequest(bookingRequest, AppState.verificationResult);
        }

        console.log('Processed booking request:', finalBookingRequest);

        // Step 3: Add to buffer (shows loading indicator automatically)
        return API.addToBuffer(finalBookingRequest)
          .then(response => {
            // Parse response if needed
            const result = typeof response === 'string' ? JSON.parse(response) : response;

            if (!result.success) {
              throw new Error(result.message || 'Failed to create booking');
            }

            console.log('Booking added to buffer successfully:', result);

            // Step 4: Update local data for immediate UI feedback
            updateLocalBookingsData(finalBookingRequest);

            // Step 5: Add to database (no waiting)
            // Use a delayed execution to ensure we don't send duplicate requests
            setTimeout(() => {
              // Double-check we haven't already submitted this to the database
              const dbTrackingId = `addBookingToDatabase_${bookingRef}`;
              if (!API.activeRequests[dbTrackingId]) {
                API.addToDatabase(finalBookingRequest)
                  .then(() => console.log('Database update completed'))
                  .catch(err => console.warn('Database update failed, will retry later:', err));
              } else {
                console.log('Database submission already in progress, skipping');
              }
            }, 1000);

            // Show success message
            Toast.show('success', 'Your booking has been confirmed!');

            // NEW STEP: Show the booking receipt instead of hiding the modal
            setTimeout(() => {
              // Show receipt with booking data
              showReservationReceipt(finalBookingRequest);
            }, 1000);

            return result;
          })
          .catch(error => {
            console.error('Error processing booking:', error);
            Toast.show('error', error.message || 'Failed to create booking. Please try again.');
            throw error;
          });
      } catch (error) {
        console.error('Error preparing booking data:', error);
        Toast.show('error', 'An error occurred while preparing your booking');
        return Promise.reject(error);
      }
    }
  }

  ///////////////// BOOKING MODAL ENDS HERE, BELOW IS A HELPER FUNCTION FOR IT

  /**
 * Clear the file preview thumbnail 
 * This should be called when clicking the upload button in the complete payment instructions
 */
  function clearFilePreview() {
    const filePreview = DOM.byId('file-preview');
    const uploadInstructions = DOM.byId('upload-instructions');
    const previewImage = DOM.byId('preview-image');

    if (filePreview) {
      DOM.hide(filePreview);
      // Also clear the image source to fully remove the previous image
      if (previewImage) {
        previewImage.src = '';
      }
    }

    if (uploadInstructions) {
      DOM.show(uploadInstructions);
    }

    // Reset the file input value
    const fileInput = DOM.byId('payment-screenshot');
    if (fileInput) {
      fileInput.value = '';
    }

    // Reset the uploaded file in AppState
    AppState.uploadedFile = null;
  }

  /**
   * Show partial payment success message
   * @param {number} paidAmount - Amount already paid
   * @param {number} remainingAmount - Amount still owed
   */
  function showPartialPaymentSuccess(paidAmount, remainingAmount) {
    // Get the verification status container
    const verificationStatus = DOM.byId('verification-status');
    if (!verificationStatus) return;

    // Fall back to AppState values if not provided
    const paid = paidAmount || AppState.partialPaymentAmount || 0;
    const remaining = remainingAmount || AppState.remainingAmount || 0;
    const total = paid + remaining;

    // Create partial payment success UI
    verificationStatus.innerHTML = `
    <div class="status-success partial-success">
      <div class="status-success-header">
        <i class="fas fa-check-circle status-success-icon"></i>
        <h3 class="status-success-title">Partial Payment Accepted</h3>
      </div>
      <div class="status-success-details">
        <p>Your booking has been confirmed with a partial payment. A balance is still due.</p>
        <div class="payment-summary">
          <div class="payment-row">
            <span>Paid Amount:</span>
            <span>EGP ${paid.toFixed(2)}</span>
          </div>
          <div class="payment-row highlight">
            <span>Remaining Balance:</span>
            <span>EGP ${remaining.toFixed(2)}</span>
          </div>
          <div class="payment-row total">
            <span>Total Price:</span>
            <span>EGP ${total.toFixed(2)}</span>
          </div>
        </div>
        <div class="payment-instructions">
          <p>You can pay the remaining balance:</p>
          <ul>
            <li>Upon arrival at the venue</li>
            <li>Through another InstaPay payment before your booking</li>
          </ul>
        </div>
      </div>
    </div>
  `;

    // Add some quick CSS for the partial payment success
    const styleElement = document.createElement('style');
    styleElement.id = 'partial-success-styles';
    styleElement.textContent = `
    .partial-success {
      border-color: #047857;
    }
    
    .partial-success .status-success-header {
      background-color: #d1fae5;
    }
    
    .payment-summary {
      background-color: #f9fafb;
      border-radius: 6px;
      padding: 12px;
      margin: 12px 0;
    }
    
    .payment-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
    }
    
    .payment-row.highlight {
      font-weight: bold;
      color: #f59e0b;
      border-bottom: 1px solid #e5e7eb;
      border-top: 1px solid #e5e7eb;
      padding: 10px 0;
      margin: 6px 0;
    }
    
    .payment-row.total {
      font-weight: bold;
      margin-top: 6px;
    }
    
    .payment-instructions {
      margin-top: 16px;
    }
    
    .payment-instructions ul {
      padding-left: 20px;
    }
    
    .payment-instructions li {
      margin: 6px 0;
    }
  `;

    if (!document.getElementById('partial-success-styles')) {
      document.head.appendChild(styleElement);
    }

    // Show confirmation button
    const confirmationAction = DOM.byId('confirmation-action');
    if (confirmationAction) {
      DOM.show(confirmationAction);
    }

    // Hide action buttons
    const actionButtons = DOM.byId('verify-payment')?.parentNode;
    if (actionButtons) {
      DOM.hide(actionButtons);
    }
  }

  /**
 * Show success message when a complete payment is made after a partial payment
 * @param {number} totalAmount - The total amount paid
 */
  function showCompletePaymentSuccess(totalAmount) {
    const verificationStatus = DOM.byId('verification-status');
    if (!verificationStatus) return;

    verificationStatus.innerHTML = `
    <div class="status-success">
      <div class="status-success-header">
        <i class="fas fa-check-circle status-success-icon"></i>
        <h3 class="status-success-title">Payment Completed Successfully</h3>
      </div>
      <div class="status-success-details">
        <p>You have successfully paid the full amount for your booking.</p>
        <div class="payment-summary">
          <div class="payment-row total">
            <span>Total Paid:</span>
            <span>EGP ${totalAmount.toFixed(2)}</span>
          </div>
        </div>
        <p>Your booking is now confirmed. Thank you!</p>
      </div>
    </div>
  `;

    // Show confirmation button
    const confirmationAction = DOM.byId('confirmation-action');
    if (confirmationAction) {
      DOM.show(confirmationAction);
    }

    // Hide action buttons
    const actionButtons = DOM.byId('verify-payment')?.parentNode;
    if (actionButtons) {
      DOM.hide(actionButtons);
    }

    // Process the booking with the completed payment
    setTimeout(() => {
      BookingModal.handleVerifiedInstapayPayment(false); // Not partial anymore
    }, 500);
  }

  /**
 * Show reservation receipt after booking is confirmed
 * This replaces or enhances the final step of booking confirmation
 * 
 * @param {Object} bookingData - The confirmed booking data
 */
  function showReservationReceipt(bookingData) {
    // Get the container - this could be the booking modal content
    // or another designated area for the receipt

    BookingModal.cleanupModalContent();
    const modalContent = document.querySelector('.modal-content');
    if (!modalContent) return;

    // Extract booking details from the data
    const {
      resourceName,
      date,
      startTime,
      endTime,
      price,
      paymentMethod,
      reference,
      // Check for partial payment info
      partialPayment
    } = bookingData;

    // Format date
    const formattedDate = new Date(date).toLocaleDateString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    });

    // Format time
    const formattedStartTime = Utils.formatTime(startTime);
    const formattedEndTime = Utils.formatTime(endTime);

    // Calculate duration
    const startMinutes = Utils.convertTimeToMinutes(startTime);
    const endMinutes = Utils.convertTimeToMinutes(endTime);
    const durationHours = (endMinutes - startMinutes) / 60;
    const formattedDuration = Utils.formatDuration(durationHours);

    // Generate QR code data - combine resource, date, time, reference
    const qrData = `KROO:${reference}:${resourceName}:${date}:${startTime}-${endTime}`;

    // Clear all existing steps
    BookingModal.hideAllSteps();

    // Create new receipt step
    const receiptStep = document.createElement('div');
    receiptStep.id = 'booking-receipt-step';
    receiptStep.className = 'booking-step';
    receiptStep.style.display = 'block';

    // Set up receipt content with nice theme-matching styling
    receiptStep.innerHTML = `
    <div class="receipt-container">
      <div class="receipt-header">
        <div class="receipt-logo">
          <i class="fas fa-check-circle"></i>
        </div>
        <h2 class="receipt-title">Booking Confirmed</h2>
        <p class="receipt-subtitle">Your reservation has been successfully booked</p>
      </div>
      
      <div class="receipt-confirmation-number">
        <span class="label">Booking Reference:</span>
        <span class="value">${reference}</span>
      </div>
      
      <div class="receipt-body">
        <div class="receipt-section">
          <h3 class="section-title">
            <i class="fas fa-building"></i> Resource
          </h3>
          <p class="section-content">${resourceName}</p>
        </div>
        
        <div class="receipt-section">
          <h3 class="section-title">
            <i class="fas fa-calendar-alt"></i> Date
          </h3>
          <p class="section-content">${formattedDate}</p>
        </div>
        
        <div class="receipt-section">
          <h3 class="section-title">
            <i class="fas fa-clock"></i> Time
          </h3>
          <p class="section-content">${formattedStartTime} - ${formattedEndTime} (${formattedDuration})</p>
        </div>
        
        <div class="receipt-section">
          <h3 class="section-title">
            <i class="fas fa-money-bill-wave"></i> Payment
          </h3>
          <div class="payment-details">
            <div class="payment-row">
              <span class="payment-label">Amount:</span>
              <span class="payment-value">EGP ${price.toFixed(2)}</span>
            </div>
            <div class="payment-row">
              <span class="payment-label">Method:</span>
              <span class="payment-value">${Utils.capitalizeFirstLetter(paymentMethod)}</span>
            </div>
            ${partialPayment ? `
              <div class="payment-row highlight">
                <span class="payment-label">Payment Status:</span>
                <span class="payment-value">Partial Payment</span>
              </div>
              <div class="payment-row">
                <span class="payment-label">Paid Amount:</span>
                <span class="payment-value">EGP ${partialPayment.paid.toFixed(2)}</span>
              </div>
              <div class="payment-row">
                <span class="payment-label">Remaining:</span>
                <span class="payment-value">EGP ${partialPayment.remaining.toFixed(2)}</span>
              </div>
            ` : ''}
          </div>
        </div>
      </div>
      
      <div class="receipt-qr">
        <div class="qr-code" id="booking-qr"></div>
        <p class="qr-help">Show this QR code at the venue</p>
      </div>
      
      <div class="receipt-actions">
        <button id="download-receipt" class="btn btn-outline">
          <i class="fas fa-download"></i> Download Receipt
        </button>
        <button id="close-receipt" class="btn btn-primary">
          <i class="fas fa-check"></i> Done
        </button>
      </div>
    </div>
  `;

    // Add receipt to modal content
    modalContent.appendChild(receiptStep);

    // Add CSS for the receipt
    const styleElement = document.createElement('style');
    styleElement.id = 'receipt-styles';
    styleElement.textContent = `
    .receipt-container {
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 2rem;
      max-width: 500px;
      margin: 0 auto;
    }
    
    .receipt-header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .receipt-logo {
      font-size: 3rem;
      color: #f59e0b;
      margin-bottom: 1rem;
    }
    
    .receipt-title {
      color: #1e293b;
      font-size: 1.5rem;
      margin: 0 0 0.5rem 0;
    }
    
    .receipt-subtitle {
      color: #64748b;
      margin: 0;
    }
    
    .receipt-confirmation-number {
      background-color: #fffbeb;
      border: 1px solid #fcd34d;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .receipt-confirmation-number .label {
      color: #92400e;
      font-weight: 500;
    }
    
    .receipt-confirmation-number .value {
      color: #d97706;
      font-weight: bold;
      font-family: monospace;
      font-size: 1.1rem;
    }
    
    .receipt-body {
      margin-bottom: 1.5rem;
    }
    
    .receipt-section {
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #e5e7eb;
    }
    
    .receipt-section:last-child {
      border-bottom: none;
    }
    
    .section-title {
      color: #64748b;
      font-size: 0.875rem;
      font-weight: 500;
      margin: 0 0 0.5rem 0;
      display: flex;
      align-items: center;
    }
    
    .section-title i {
      color: #f59e0b;
      margin-right: 0.5rem;
    }
    
    .section-content {
      color: #1e293b;
      font-size: 1rem;
      font-weight: 500;
      margin: 0;
    }
    
    .payment-details {
      display: flex;
      flex-direction: column;
    }
    
    .payment-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }
    
    .payment-row.highlight {
      font-weight: bold;
      color: #f59e0b;
      border-bottom: 1px solid #e5e7eb;
      border-top: 1px solid #e5e7eb;
      padding: 0.5rem 0;
      margin: 0.5rem 0;
    }
    
    .payment-label {
      color: #64748b;
    }
    
    .payment-value {
      color: #1e293b;
      font-weight: 500;
    }
    
    .receipt-qr {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    
    .qr-code {
      width: 150px;
      height: 150px;
      background-color: #f1f5f9;
      border: 1px solid #e5e7eb;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .qr-help {
      color: #64748b;
      font-size: 0.875rem;
      margin: 0;
    }
    
    .receipt-actions {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
    }
    
    .receipt-actions button {
      flex: 1;
      padding: 0.75rem 1rem;
    }
  `;

    if (!document.getElementById('receipt-styles')) {
      document.head.appendChild(styleElement);
    }

    // Initialize QR code (if you have a QR library available)
    // If you don't have a QR library, you can use a placeholder or leave this part out
    try {
      // This is a placeholder - replace with your actual QR code generation
      // Example using qrcode.js library:
      if (typeof QRCode !== 'undefined') {
        new QRCode(document.getElementById('booking-qr'), {
          text: qrData,
          width: 150,
          height: 150
        });
      } else {
        // Fallback to placeholder
        const qrElement = document.getElementById('booking-qr');
        if (qrElement) {
          qrElement.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;"><i class="fas fa-qrcode" style="font-size:3rem;color:#cbd5e1;"></i></div>';
        }
      }
    } catch (error) {
      console.warn('Could not generate QR code:', error);
    }

    // Add event listeners for the buttons
    setTimeout(() => {
      const downloadBtn = document.getElementById('download-receipt');
      const closeBtn = document.getElementById('close-receipt');

      if (downloadBtn) {
        downloadBtn.addEventListener('click', () => {
          // Simple implementation - open a printable version
          // In a real app, you'd generate a PDF or image
          const printWindow = window.open('', '_blank');
          if (printWindow) {
            printWindow.document.write(`
            <html>
              <head>
                <title>Booking Receipt - ${reference}</title>
                <style>
                  body { font-family: Arial, sans-serif; padding: 20px; }
                  .header { text-align: center; margin-bottom: 20px; }
                  .detail { margin-bottom: 10px; }
                  .label { font-weight: bold; }
                </style>
              </head>
              <body>
                <div class="header">
                  <h1>Booking Confirmation</h1>
                  <p>Reference: ${reference}</p>
                </div>
                <div class="detail">
                  <span class="label">Resource:</span> ${resourceName}
                </div>
                <div class="detail">
                  <span class="label">Date:</span> ${formattedDate}
                </div>
                <div class="detail">
                  <span class="label">Time:</span> ${formattedStartTime} - ${formattedEndTime}
                </div>
                <div class="detail">
                  <span class="label">Duration:</span> ${formattedDuration}
                </div>
                <div class="detail">
                  <span class="label">Amount:</span> EGP ${price.toFixed(2)}
                </div>
                <div class="detail">
                  <span class="label">Payment Method:</span> ${Utils.capitalizeFirstLetter(paymentMethod)}
                </div>
                ${partialPayment ? `
                  <div class="detail">
                    <span class="label">Payment Status:</span> Partial Payment
                  </div>
                  <div class="detail">
                    <span class="label">Paid Amount:</span> EGP ${partialPayment.paid.toFixed(2)}
                  </div>
                  <div class="detail">
                    <span class="label">Remaining:</span> EGP ${partialPayment.remaining.toFixed(2)}
                  </div>
                ` : ''}
                <div style="margin-top: 30px; text-align: center;">
                  <p>Thank you for using KROO Reservations!</p>
                </div>
              </body>
            </html>
          `);
            printWindow.document.close();
            printWindow.print();
          } else {
            Toast.show('error', 'Could not open print window. Please check your browser settings.');
          }
        });
      }

      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          BookingModal.hide();
          // Refresh resources view
          // UI.renderResources();
          // Also refresh bookings view in case user navigates there  
          UI.renderBookings();
        });
      }
    }, 100);
  }

  /**
   * Update local data structures for immediate UI feedback
   * Uses data already formatted by formulateBookingRequest
   */
  function updateLocalBookingsData(bookingData) {
    console.log('=== updateLocalBookingsData DEBUG ===');
    console.log('bookingData:', bookingData);
    console.log('AppState.initialMode:', AppState.initialMode);
    console.log('About to check if initialMode === guest');

    const uiBooking = {
      ...bookingData,
      id: Date.now()
    };
    console.log('uiBooking created:', uiBooking);

    // Use the INITIAL/LOCKED mode, not current state
    if (AppState.initialMode === 'guest') {
      console.log('✅ GUEST MODE DETECTED - STORING IN COOKIES');

      // Test if BookingStorage exists
      console.log('BookingStorage object:', BookingStorage);
      console.log('storeGuestBooking function:', BookingStorage.storeGuestBooking);

      try {
        const storedBooking = BookingStorage.storeGuestBooking(uiBooking);
        console.log('✅ storeGuestBooking returned:', storedBooking);

        // Verify it was stored
        const retrievedBookings = BookingStorage.getGuestBookings();
        console.log('✅ Retrieved bookings after storage:', retrievedBookings);

        // Check raw cookies
        console.log('✅ Raw document.cookie:', document.cookie);
      } catch (error) {
        console.error('❌ Error in storeGuestBooking:', error);
      }
    } else {
      console.log('❌ NOT GUEST MODE - mode:', AppState.initialMode);
    }

    console.log('Adding to local bookings array...');
    bookings.push(uiBooking);
    console.log('Local bookings array now has', bookings.length, 'items');

    bookedSlots.push({
      resourceId: bookingData.resourceId,
      date: bookingData.date,
      startTime: bookingData.startTime,
      endTime: bookingData.endTime
    });
    console.log('=== END updateLocalBookingsData DEBUG ===');
  }


  // Optional: Admin filter component for bookings view
  // Only add this if you want to enhance the admin experience

  function addAdminFilters() {
    // Only proceed if user is admin
    if (!AppState.isAdmin) return;

    // Look for the bookings header
    const bookingsHeader = document.querySelector('.bookings-header');
    if (!bookingsHeader) return;

    // Check if filters already exist
    if (document.querySelector('.admin-filters')) return;

    // Create filters container
    const filtersContainer = document.createElement('div');
    filtersContainer.className = 'admin-filters';

    // Create user filter dropdown
    const userSelect = document.createElement('select');
    userSelect.id = 'admin-user-filter';

    // Add default option
    let options = '<option value="">All Users</option>';

    // Get unique user emails from bookings
    const userEmails = [...new Set(bookings
      .filter(booking => booking.userDetails && booking.userDetails.email)
      .map(booking => booking.userDetails.email))];

    // Add option for each user
    userEmails.forEach(email => {
      // Find a booking with this user to get their name
      const booking = bookings.find(b => b.userDetails && b.userDetails.email === email);
      const name = booking && booking.userDetails.name ? booking.userDetails.name : email;

      options += `<option value="${email}">${name}</option>`;
    });

    userSelect.innerHTML = options;

    // Create search input
    const searchContainer = document.createElement('div');
    searchContainer.className = 'search-input';

    searchContainer.innerHTML = `
    <i class="fas fa-search"></i>
    <input type="text" id="admin-search-filter" placeholder="Search bookings...">
  `;

    // Add filters to container
    filtersContainer.appendChild(userSelect);
    filtersContainer.appendChild(searchContainer);

    // Add container after header
    bookingsHeader.after(filtersContainer);

    // Add event listeners
    userSelect.addEventListener('change', applyAdminFilters);
    searchContainer.querySelector('input').addEventListener('input', applyAdminFilters);
  }

  function applyAdminFilters() {
    // Only run if admin
    if (!AppState.isAdmin) return;

    // Get filter values
    const userFilter = document.getElementById('admin-user-filter').value;
    const searchFilter = document.getElementById('admin-search-filter').value.toLowerCase();

    // Re-render bookings with these filters
    renderAdminFilteredBookings(userFilter, searchFilter);
  }

  function renderAdminFilteredBookings(userFilter, searchFilter) {
    // This is a placeholder function that would work similarly to renderBookings
    // but with additional filtering based on userFilter and searchFilter

    // For now, just call the regular render method
    // In a full implementation, you would modify this to apply the additional filters
    UI.renderBookings();

    console.log('Admin filters applied:', { userFilter, searchFilter });
  }

  // Call this function after the page is loaded to add admin filters if needed
  document.addEventListener('DOMContentLoaded', function () {
    setTimeout(addAdminFilters, 1000);
  });

  ///////////////////////////// FORMULATE BOOKING OBJ START

  /**
  * Sets up the partial payment UI buttons and handlers
  * @param {number} paidAmount - Amount already paid
  * @param {number} remainingAmount - Amount still owed
  */
  function setupPartialPaymentButton(paidAmount, remainingAmount) {
    // Store partial payment info in AppState for later use
    AppState.partialPaymentAmount = paidAmount;
    AppState.remainingAmount = remainingAmount;

    // Remove any existing button first
    const existingBtn = document.getElementById('accept-partial-payment');
    if (existingBtn) {
      existingBtn.remove();
    }

    const verificationStatus = DOM.byId('verification-status');
    if (!verificationStatus) return;

    const warningSection = verificationStatus.querySelector('.status-partial-details') ||
      verificationStatus.querySelector('.status-warning-details');

    if (!warningSection) return;

    // Check if buttons container already exists
    let buttonContainer = warningSection.querySelector('.partial-payment-options');

    // If not, create it
    if (!buttonContainer) {
      buttonContainer = document.createElement('div');
      buttonContainer.className = 'partial-payment-options';
      buttonContainer.style.display = 'flex';
      buttonContainer.style.justifyContent = 'space-between';
      buttonContainer.style.marginTop = '16px';
      buttonContainer.style.gap = '12px';
      warningSection.appendChild(buttonContainer);
    } else {
      // Clear existing content
      buttonContainer.innerHTML = '';
    }

    // Create Accept button
    const acceptBtn = document.createElement('button');
    acceptBtn.id = 'accept-partial-payment';
    acceptBtn.className = 'btn btn-outline';
    acceptBtn.textContent = 'Accept Partial Payment';
    acceptBtn.style.flex = '1';

    // Create Complete button
    const completeBtn = document.createElement('button');
    completeBtn.id = 'complete-payment';
    completeBtn.className = 'btn btn-primary';
    completeBtn.textContent = 'Complete Payment';
    completeBtn.style.flex = '1';

    // Add buttons to container
    buttonContainer.appendChild(acceptBtn);
    buttonContainer.appendChild(completeBtn);

    // Add event listeners
    acceptBtn.addEventListener('click', function () {
      // Call with explicit isPartial=true flag
      BookingModal.handleVerifiedInstapayPayment(true);
    });

    completeBtn.addEventListener('click', function () {
      // Show instructions for completing the payment
      showCompletePaymentInstructions(remainingAmount);
    });
  }

  /**
   * Formulate booking request based on user scenario
   * @param {Object} currentState - The current AppState
   * @returns {Object} Formatted booking request object
   */
  function formulateBookingRequest(currentState) {
    // Get necessary data from current state
    const {
      currentResourceId,
      selectedTimeSlot,
      selectedPaymentMethod,
      uploadedFile,
      verificationResult,
      userEmail,
      userName,
      userPhone,
      userDiscount,
      isAdmin
    } = currentState;

    // Get resource
    const resource = resources.find(r => r.id === currentResourceId);
    if (!resource) {
      throw new Error('Resource not found');
    }

    // Get payment method details
    const paymentMethodObj = paymentMethods.find(m => m.id === selectedPaymentMethod);
    if (!paymentMethodObj) {
      throw new Error('Payment method not found');
    }

    // Calculate price with discount if applicable
    const bookingPrice = selectedTimeSlot.finalPrice || selectedTimeSlot.price;

    // Use consistent BOOKING reference from AppState
    const bookingReference = AppState.getBookingReference();

    // Base booking object
    const baseBooking = {
      reference: bookingReference, // This is the BOOKING reference
      resourceId: currentResourceId,
      resourceName: resource.name,
      resourceLabel: resource.resourceLabel,
      date: selectedTimeSlot.date,
      startTime: selectedTimeSlot.startTime,
      endTime: selectedTimeSlot.endTime,
      duration: selectedTimeSlot.duration ||
        (Utils.convertTimeToMinutes(selectedTimeSlot.endTime) -
          Utils.convertTimeToMinutes(selectedTimeSlot.startTime)) / 60,
      status: 'CONFIRMED',
      price: bookingPrice,
      originalPrice: selectedTimeSlot.price,
      discountApplied: userDiscount || 0,
      paymentMethod: paymentMethodObj.id,
      paymentStatus: 'completed',
      createdAt: new Date().toISOString(),
      bookedSlot: {
        startTime: selectedTimeSlot.startTime,
        resourceId: currentResourceId,
        endTime: selectedTimeSlot.endTime,
        duration: selectedTimeSlot.duration,
        date: selectedTimeSlot.date,
      }
    };

    console.log(resource)

    // For InstaPay payments, include the payment reference as well
    if (paymentMethodObj.id === 'instapay') {
      baseBooking.paymentReference = AppState.getPaymentReference();
    }

    // ---- SCENARIO 1: Admin booking for existing user ----
    if (isAdmin && userEmail && !currentState.isNewUser) {
      return {
        ...baseBooking,
        userDetails: {
          email: userEmail,
          name: userName,
          phone: userPhone,
          discount: userDiscount || 0
        },
        createdBy: {
          email: currentState.adminEmail || userEmail, // Fallback to userEmail if adminEmail not set
          isAdmin: true
        },
        bookingType: 'ADMIN_FOR_EXISTING'
      };
    }

    // ---- SCENARIO 2: Admin creating booking for new user ----
    else if (isAdmin && currentState.isNewUser) {
      return {
        ...baseBooking,
        userDetails: {
          email: userEmail,
          name: userName,
          phone: userPhone,
          discount: userDiscount || 0,
          isNewUser: true
        },
        createdBy: {
          email: currentState.adminEmail || userEmail,
          isAdmin: true
        },
        bookingType: 'ADMIN_FOR_NEW'
      };
    }

    // ---- SCENARIO 3: Logged in user (email in URL) ----
    else if (userEmail && !isAdmin && !currentState.isNewUser) {
      return {
        ...baseBooking,
        userDetails: {
          email: userEmail,
          name: userName,
          phone: userPhone
        },
        createdBy: {
          email: userEmail,
          isAdmin: false
        },
        bookingType: 'EXISTING_USER'
      };
    }

    // ---- SCENARIO 4: Public booking (no user in URL) ----
    else {
      return {
        ...baseBooking,
        userDetails: {
          email: userEmail,
          name: userName,
          phone: userPhone,
          isNewUser: true
        },
        createdBy: {
          email: userEmail,
          isAdmin: false
        },
        bookingType: 'PUBLIC_NEW_USER'
      };
    }
  }

  /**
   * Add payment details to booking request for Instapay including partial payment support
   * @param {Object} bookingRequest - The base booking request
   * @param {Object} verificationResult - Verification result if available
   * @returns {Object} Booking request with payment details
   */
  function addPaymentDetailsToRequest(bookingRequest, verificationResult) {
    // Only add payment details for InstaPay
    if (bookingRequest.paymentMethod !== 'instapay') {
      return bookingRequest;
    }

    // If we have verification results
    if (verificationResult) {
      // Check if this is a partial payment
      const isPartialPayment = AppState.selectedTimeSlot &&
        AppState.selectedTimeSlot.isPartialPayment === true;

      // Add payment details including partial payment info if applicable
      const paymentDetails = {
        paymentReference: AppState.getPaymentReference(), // Include PAYMENT reference
        verificationImage: verificationResult.fileUrl,
        verificationStatus: verificationResult.verified ? 'VERIFIED' : 'UNVERIFIED',
        verificationMessage: verificationResult.message,
        verificationConfidence: verificationResult.confidence,
        verificationTimestamp: verificationResult.timestamp
      };

      // Add partial payment details if applicable
      if (isPartialPayment) {
        paymentDetails.isPartialPayment = true;
        paymentDetails.paidAmount = AppState.selectedTimeSlot.finalPrice;
        paymentDetails.remainingAmount = AppState.selectedTimeSlot.remainingAmount;
        paymentDetails.totalAmount = paymentDetails.paidAmount + paymentDetails.remainingAmount;

        // Set payment status for partial payments
        return {
          ...bookingRequest,
          paymentDetails: paymentDetails,
          paymentStatus: 'partial_payment',
          partialPayment: {
            paid: paymentDetails.paidAmount,
            remaining: paymentDetails.remainingAmount,
            total: paymentDetails.totalAmount
          }
        };
      }

      // Regular payment (not partial)
      return {
        ...bookingRequest,
        paymentDetails: paymentDetails,
        paymentStatus: verificationResult.verified ? 'completed' : 'pending_verification'
      };
    }

    // If no verification was done but it's InstaPay
    return {
      ...bookingRequest,
      paymentDetails: {
        paymentReference: AppState.getPaymentReference(), // Include PAYMENT reference
        verificationStatus: 'PENDING',
        verificationMessage: 'Verification pending'
      },
      paymentStatus: 'pending_verification'
    };
  }


  ///////////////////////////// FORMULATE BOOKING OBJ END


  ///////////////////////////// INSTAPAY VERFICATION HELPERS

  /**
   * Enhanced function to get user-friendly verification messages but with new decision object support
   * Using EGP currency symbol consistently
   * @param {Object} verificationResult - The verification result from the backend
   * @param {Object} decision - The new decision object from backend (optional)
   * @returns {string} A user-friendly message explaining the verification result
   */
  function getVerificationMessage(verificationResult, decision = null) {
    // If we have a decision object with a message, use that
    if (decision && decision.message) {
      return decision.message;
    }

    if (!verificationResult) {
      return 'Could not verify the payment. Please try again.';
    }

    // Direct checks based on clear flags
    const missingFields = [];

    if (!verificationResult.hasReferenceNumber) {
      missingFields.push("reference number");
    }

    if (!verificationResult.hasTimestamp) {
      missingFields.push("timestamp/date");
    }

    if (!verificationResult.hasAmount) {
      missingFields.push("payment amount");
    }

    // Create a clear message for missing fields
    if (missingFields.length > 0) {
      return `The screenshot is missing: ${missingFields.join(", ")}. Please ensure your screenshot shows the complete payment receipt.`;
    }

    // Handle cases where verification failed for other reasons
    if (!verificationResult.isLegitimate) {
      // Check if we have specific reasons provided
      if (verificationResult.reasons && verificationResult.reasons.length > 0) {
        // Return the primary reason (most important first)
        return verificationResult.reasons[0];
      }

      // Default message if no specific reasons
      return 'The payment screenshot could not be verified. Please ensure all payment details are clearly visible.';
    }

    // Handle amount-related issues
    if (verificationResult.amountStatus === 'less') {
      const remainder = Math.abs(verificationResult.remainder || 0).toFixed(2);
      return `We detected a partial payment. You need to pay an additional EGP ${remainder} to complete the booking.`;
    }

    if (verificationResult.amountStatus === 'more') {
      const extra = Math.abs(verificationResult.remainder || 0).toFixed(2);
      return `You paid EGP ${extra} more than the required amount. The booking will be confirmed.`;
    }

    // Handle successful verification
    if (verificationResult.isRightAmount) {
      return 'Payment verified successfully! Your booking is confirmed.';
    }

    // Fallback message
    return 'There was an issue with the payment verification. Please try again or contact support.';
  }

  /**
   * Enhanced function to update the verification UI with specific warnings for missing information
   * or duplicate transaction references using the new backend decision object
   * Using EGP currency symbol consistently
   * @param {Object} verificationResult - The verification result from the backend
   * @param {Object} ocrResult - OCR result data if available
   * @param {Object} decision - New decision object from backend containing status and message
   */
  /**
   * Enhanced function to update the verification UI with better handling for partial payments
   * @param {Object} verificationResult - The verification result from the backend
   * @param {Object} ocrResult - OCR result data if available
   * @param {Object} decision - New decision object from backend containing status and message
   */
  function updateVerificationUI(verificationResult, ocrResult, decision = {}) {
    const verificationStatus = DOM.byId('verification-status');
    if (!verificationStatus) return;

    // Default values if some properties are missing
    const isLegitimate = verificationResult?.isLegitimate || false;
    const isRightAmount = verificationResult?.isRightAmount || false;
    const amountStatus = verificationResult?.amountStatus || 'unknown';
    const remainder = verificationResult?.remainder || 0;

    // Get confidence value from OCR for amount if available
    let confidenceDisplay = 'Medium';
    if (ocrResult?.confidence?.amount) {
      const confidencePercent = (ocrResult.confidence.amount * 100).toFixed(1);
      confidenceDisplay = `${confidencePercent}%`;
    }

    // Check for specific issues
    const reasons = verificationResult?.reasons || [];
    const warnings = verificationResult?.warnings || [];

    // Generate a verification ID for successful verifications
    const verificationId = `VRF-${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 7)}`.toUpperCase();

    // Get decision data from new backend response
    const decisionStatus = decision?.decision || null;  // 'APPROVED', 'REJECTED', 'PARTIAL'
    const decisionMessage = decision?.message || null;
    const decisionCode = decision?.primaryCode || null;

    // Direct "missing fields" check
    const missingFields = [];

    if (!verificationResult.hasReferenceNumber) {
      missingFields.push("reference number");
    }

    if (!verificationResult.hasTimestamp) {
      missingFields.push("date/time");
    }

    if (!verificationResult.hasAmount) {
      missingFields.push("payment amount");
    }

    if (missingFields.length > 0) {
      // Create clear error with exactly what's missing
      verificationStatus.innerHTML = `
      <div class="status-error">
        <div class="status-error-header">
          <i class="fas fa-times-circle status-error-icon"></i>
          <h3 class="status-error-title">Verification Failed</h3>
        </div>
        <div class="status-error-details">
          <p>The screenshot is missing: ${missingFields.join(", ")}</p>
          <div class="error-example">
            <p class="error-example-title">Please ensure your screenshot includes:</p>
            <ul class="error-example-list">
              ${!verificationResult.hasReferenceNumber ? '<li class="critical-error">- Transaction reference number</li>' : ''}
              ${!verificationResult.hasTimestamp ? '<li class="critical-error">- Date and time of the transaction</li>' : ''}
              ${!verificationResult.hasAmount ? '<li class="critical-error">- Payment amount</li>' : ''}
              <li>- The complete payment receipt</li>
            </ul>
          </div>
        </div>
      </div>
    `;
      return;
    }

    // Handle based on decision from backend if available
    if (decisionStatus === 'APPROVED' || (isLegitimate && isRightAmount)) {
      // Payment is fully verified
      verificationStatus.innerHTML = `
      <div class="status-success">
        <div class="status-success-header">
          <i class="fas fa-check-circle status-success-icon"></i>
          <h3 class="status-success-title">Payment Verified Successfully</h3>
        </div>
        <div class="status-success-details">
          <p>${decisionMessage || 'Your payment has been verified and your booking is confirmed.'}</p>
          <ul class="status-success-list">
            <li>Amount: EGP ${AppState.selectedTimeSlot.finalPrice.toFixed(2)}</li>
            <li>Confidence: ${confidenceDisplay}</li>
            <li>Verification ID: ${verificationId}</li>
            ${verificationResult.metadataTimestampUsed ? '<li>Used image metadata timestamp for verification</li>' : ''}
          </ul>
        </div>
      </div>
    `;

      // Show confirmation button
      const confirmationAction = DOM.byId('confirmation-action');
      if (confirmationAction) {
        DOM.show(confirmationAction);
      }

      // Hide action buttons
      const actionButtons = DOM.byId('verify-payment')?.parentNode;
      if (actionButtons) {
        DOM.hide(actionButtons);
      }
    }
    else if (decisionStatus === 'PARTIAL' || (isLegitimate && amountStatus === 'less')) {
      // Payment is legitimate but amount is less than expected
      const paidAmount = AppState.selectedTimeSlot.finalPrice - Math.abs(remainder);
      const remainingAmount = Math.abs(remainder);
      const percentPaid = Math.round((paidAmount / AppState.selectedTimeSlot.finalPrice) * 100);

      // Add partial payment styling if not already added
      addPartialPaymentCSS();

      verificationStatus.innerHTML = `
    <div class="status-partial">
      <div class="status-partial-header">
        <i class="fas fa-percentage status-partial-icon"></i>
        <h3 class="status-partial-title">Partial Payment Detected</h3>
      </div>
      <div class="status-partial-details">
        <p>${decisionMessage || `We've detected a payment for ${percentPaid}% of the required amount.`}</p>
        
        <div class="payment-progress">
          <div class="payment-progress-bar" style="width: ${percentPaid}%">
            <span class="payment-progress-text">${percentPaid}%</span>
          </div>
        </div>
        
        <ul class="status-partial-list">
          <li>Paid: EGP ${paidAmount.toFixed(2)}</li>
          <li>Remaining: EGP ${remainingAmount.toFixed(2)}</li>
          <li>Total required: EGP ${AppState.selectedTimeSlot.finalPrice.toFixed(2)}</li>
        </ul>
      </div>
    </div>
  `;

      // Set up the partial payment buttons with the calculated amounts
      setTimeout(() => {
        setupPartialPaymentButton(paidAmount, remainingAmount);
      }, 100);
    }
    else if (decisionStatus === 'OVERPAID' || (isLegitimate && amountStatus === 'more')) {
      // Payment is legitimate but amount is more than expected
      const paidAmount = AppState.selectedTimeSlot.finalPrice + Math.abs(remainder);

      verificationStatus.innerHTML = `
      <div class="status-info">
        <div class="status-info-header">
          <i class="fas fa-info-circle status-info-icon"></i>
          <h3 class="status-info-title">Overpayment Detected</h3>
        </div>
        <div class="status-info-details">
          <p>${decisionMessage || 'We\'ve detected a payment with an amount higher than required:'}</p>
          <ul class="status-info-list">
            <li>Required: EGP ${AppState.selectedTimeSlot.finalPrice.toFixed(2)}</li>
            <li>Paid: EGP ${paidAmount.toFixed(2)}</li>
            <li>Excess: EGP ${Math.abs(remainder).toFixed(2)}</li>
          </ul>
          <p>The booking will be confirmed with the extra amount noted.</p>
        </div>
      </div>
    `;

      // Show confirmation button
      const confirmationAction = DOM.byId('confirmation-action');
      if (confirmationAction) {
        DOM.show(confirmationAction);
      }

      // Hide action buttons
      const actionButtons = DOM.byId('verify-payment')?.parentNode;
      if (actionButtons) {
        DOM.hide(actionButtons);
      }
    }
    else {
      // Payment verification failed - use decision message from backend if available
      // Check for specific issues
      const hasDuplicateReferenceIssue = reasons.some(reason =>
        reason.toLowerCase().includes('duplicate') ||
        reason.toLowerCase().includes('already used') ||
        reason.toLowerCase().includes('previously verified')
      ) || decisionCode === 3; // Assuming code 3 is for duplicate reference

      const hasOldTransactionIssue = reasons.some(reason =>
        reason.toLowerCase().includes('too old') ||
        reason.toLowerCase().includes('ago, max allowed')
      ) || decisionCode === 4;

      // Create custom error list based on issues
      let reasonsList = '';

      // Don't repeat the message in the list when using decisionMessage
      if (hasDuplicateReferenceIssue) {
        // Show duplicate reference error with special styling
        reasonsList = `
        <ul class="status-error-list">
          <li class="duplicate-error">This transaction has already been used for another booking</li>
          <li>Each payment can only be used once in our system</li>
          <li>Please make a new payment for this booking</li>
          <li>Or contact support if you believe this is an error</li>
        </ul>
      `;
      }
      else if (decisionMessage) {
        // Don't include a list if we're using the decision message
        reasonsList = '';
      }
      else if (reasons.length > 0) {
        // Show all provided reasons
        reasonsList = `
        <ul class="status-error-list reasons-list">
          ${reasons.map(reason => `<li>${reason}</li>`).join('')}
        </ul>
      `;
      }
      else {
        // Generic guidance
        reasonsList = `
        <ul class="status-error-list">
          <li>The image is clear and not cropped</li>
          <li>The payment reference number is visible</li>
          <li>The payment amount and date are visible</li>
        </ul>
      `;
      }

      // Extra help for different issues
      let extraHelp = '';

      if (hasDuplicateReferenceIssue) {
        extraHelp = `
        <div class="error-example">
          <p class="error-example-title">What to do:</p>
          <ul class="error-example-list">
            <li>1. Make a new payment for this booking</li>
            <li>2. Upload the screenshot of the new payment</li>
            <li>3. Ensure you don't reuse payment screenshots</li>
          </ul>
        </div>
      `;
      }
      else if (hasOldTransactionIssue || decisionCode === 4 || decisionCode === 2) { // Time-related errors
        extraHelp = `
        <div class="error-example">
          <p class="error-example-title">What to do:</p>
          <ul class="error-example-list">
            <li>1. Make a new payment for this booking</li>
            <li>2. Upload the screenshot immediately after making the payment</li>
            <li>3. Ensure the transaction timestamp is recent (less than 10 minutes old)</li>
          </ul>
        </div>
      `;
      }
      else {
        extraHelp = `
        <div class="error-example">
          <p class="error-example-title">Example of a complete receipt:</p>
          <div class="error-example-image">
            <i class="fas fa-receipt"></i>
          </div>
          <ul class="error-example-list">
            <li>✓ Amount clearly visible</li>
            <li>✓ Date and time of transaction</li>
            <li>✓ Transaction reference or ID</li>
            <li>✓ Payment method details</li>
          </ul>
        </div>
      `;
      }

      verificationStatus.innerHTML = `
      <div class="status-error">
        <div class="status-error-header">
          <i class="fas fa-times-circle status-error-icon"></i>
          <h3 class="status-error-title">Verification Failed</h3>
        </div>
        <div class="status-error-details">
          <p>${decisionMessage || getVerificationMessage(verificationResult)}</p>
          ${reasonsList}
          ${extraHelp}
          ${!hasDuplicateReferenceIssue && !hasOldTransactionIssue ? `<p style="margin-top: 0.5rem;">Try uploading a clearer image that shows all required information.</p>` : ''}
        </div>
      </div>
    `;
    }
  }

  /**
   * Add CSS styles for partial payment UI
   */
  function addPartialPaymentCSS() {
    // Check if styles already exist
    if (document.getElementById('partial-payment-styles')) return;

    const styleElement = document.createElement('style');
    styleElement.id = 'partial-payment-styles';
    styleElement.textContent = `
    .status-partial {
      border: 1px solid #f59e0b;
      border-radius: 8px;
      background-color: #fffbeb;
      overflow: hidden;
    }
    
    .status-partial-header {
      display: flex;
      align-items: center;
      padding: 16px;
      background-color: #fef3c7;
      border-bottom: 1px solid #f59e0b;
    }
    
    .status-partial-icon {
      color: #d97706;
      font-size: 1.5rem;
      margin-right: 12px;
    }
    
    .status-partial-title {
      color: #92400e;
      margin: 0;
      font-size: 1.25rem;
    }
    
    .status-partial-details {
      padding: 16px;
    }
    
    .status-partial-list {
      list-style: none;
      padding: 0;
      margin: 12px 0;
    }
    
    .status-partial-list li {
      padding: 4px 0;
      display: flex;
      justify-content: space-between;
    }
    
    .payment-progress {
      height: 20px;
      background-color: #e5e7eb;
      border-radius: 10px;
      margin: 12px 0;
      overflow: hidden;
    }
    
    .payment-progress-bar {
      height: 100%;
      background-color: #f59e0b;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: width 0.5s ease;
      position: relative;
    }
    
    .payment-progress-text {
      color: white;
      font-weight: bold;
      font-size: 0.75rem;
      position: absolute;
      right: 8px;
    }
    
    .partial-payment-options {
      display: flex;
      justify-content: space-between;
      margin-top: 16px;
      gap: 12px;
    }
    
    .partial-payment-options button {
      flex: 1;
    }
  `;

    document.head.appendChild(styleElement);
  }

  /**
  * Show instructions for completing the payment with theme-matching styling
  * @param {number} remainingAmount - Amount still to be paid
  */
  function showCompletePaymentInstructions(remainingAmount) {
    const verificationStatus = DOM.byId('verification-status');
    if (!verificationStatus) return;

    // Store the remaining amount in case we need it later
    AppState.remainingAmount = remainingAmount;

    // Update the expected amount in AppState for next verification
    // This is crucial so the next upload is verified against the remaining amount
    AppState.expectedRemainingAmount = remainingAmount;

    verificationStatus.innerHTML = `
    <div class="status-info payment-completion">
      <div class="status-info-header">
        <i class="fas fa-info-circle status-info-icon"></i>
        <h3 class="status-info-title">Complete Your Payment</h3>
      </div>
      <div class="status-info-details">
        <div class="remaining-amount-banner">
          <span class="amount-label">Please pay the remaining balance:</span>
          <span class="amount-value">EGP ${remainingAmount.toFixed(2)}</span>
        </div>
        
        <div class="payment-instructions">
          <div class="instructions-header">
            <i class="fas fa-credit-card"></i>
            <span>Payment Instructions</span>
          </div>
          <ol class="payment-steps">
            <li>
              <span class="step-number">1</span>
              <span class="step-text">Open your InstaPay app and make a new payment</span>
            </li>
            <li>
              <span class="step-number">2</span>
              <span class="step-text">Transfer <strong>EGP ${remainingAmount.toFixed(2)}</strong> to the same recipient</span>
            </li>
            <li>
              <span class="step-number">3</span>
              <span class="step-text">Take a screenshot of the new payment receipt</span>
            </li>
            <li>
              <span class="step-number">4</span>
              <span class="step-text">Upload the screenshot below</span>
            </li>
          </ol>
        </div>
        
        <div class="action-buttons">
          <button id="back-to-partial" class="btn btn-outline">
            <i class="fas fa-arrow-left"></i> Back
          </button>
          <button id="upload-new-payment" class="btn btn-primary">
            <i class="fas fa-upload"></i> Upload New Payment
          </button>
        </div>
      </div>
    </div>
  `;

    // Add special CSS for this view - using theme-appropriate colors
    // The primary color used here is #f59e0b (amber-500)
    const styleElement = document.createElement('style');
    styleElement.id = 'payment-instructions-styles';
    styleElement.textContent = `
    .payment-completion {
      border-color: #f59e0b;
    }
    
    .payment-completion .status-info-header {
      background-color: #fffbeb;
    }
    
    .payment-completion .status-info-icon {
      color: #f59e0b;
    }
    
    .payment-completion .status-info-title {
      color: #92400e;
    }
    
    .remaining-amount-banner {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #fffbeb;
      border: 1px solid #fcd34d;
      border-radius: 8px;
      padding: 12px 16px;
      margin: 16px 0;
    }
    
    .amount-label {
      font-size: 1rem;
      color: #92400e;
    }
    
    .amount-value {
      font-size: 1.25rem;
      font-weight: bold;
      color: #d97706;
    }
    
    .instructions-header {
      display: flex;
      align-items: center;
      margin-bottom: 16px;
      color: #4b5563;
      font-weight: 500;
    }
    
    .instructions-header i {
      margin-right: 8px;
      color: #f59e0b;
    }
    
    .payment-steps {
      list-style: none;
      padding: 0;
      margin: 0 0 24px 0;
    }
    
    .payment-steps li {
      display: flex;
      align-items: flex-start;
      margin-bottom: 16px;
      line-height: 1.5;
    }
    
    .step-number {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 28px;
      height: 28px;
      background-color: #f59e0b;
      color: white;
      border-radius: 50%;
      margin-right: 12px;
      flex-shrink: 0;
      font-weight: bold;
    }
    
    .step-text {
      padding-top: 4px;
    }
    
    .action-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 24px;
      gap: 16px;
    }
    
    .action-buttons button {
      flex: 1;
      padding: 12px 16px;
      border-radius: 8px;
      font-weight: 500;
    }
    
    .action-buttons i {
      margin-right: 8px;
    }
  `;

    if (!document.getElementById('payment-instructions-styles')) {
      document.head.appendChild(styleElement);
    }

    // Add event listeners
    setTimeout(() => {
      const backBtn = document.getElementById('back-to-partial');
      const uploadBtn = document.getElementById('upload-new-payment');

      if (backBtn) {
        backBtn.addEventListener('click', () => {
          // Go back to verification by re-running verification with existing data
          const verificationResult = AppState.verificationResult?.detailedResult?.verificationResult || {};
          const ocrResult = AppState.verificationResult?.detailedResult?.ocrResult || {};
          const decision = AppState.verificationResult?.detailedResult?.decision || {};

          updateVerificationUI(verificationResult, ocrResult, decision);
        });
      }

      if (uploadBtn) {
        uploadBtn.addEventListener('click', () => {
          // Clear the file preview if it exists
          clearFilePreview();

          // Reset file input and trigger click
          const fileInput = DOM.byId('payment-screenshot');
          if (fileInput) {
            fileInput.value = '';
            fileInput.click();
          }
        });
      }
    }, 100);
  }

  /**
   * Clear the file preview thumbnail
   */
  function clearFilePreview() {
    const filePreview = DOM.byId('file-preview');
    const uploadInstructions = DOM.byId('upload-instructions');

    if (filePreview) {
      DOM.hide(filePreview);
    }

    if (uploadInstructions) {
      DOM.show(uploadInstructions);
    }

    // Reset the uploaded file in AppState
    AppState.uploadedFile = null;
  }

  /////////////////////// 🤔🤔🤔🤔

  // Super direct solution to update Instapay payment details
  // Now using EGP consistently
  BookingModal.updateInstapayPaymentDetails = function () {
    if (!AppState.selectedTimeSlot) return;

    // Get the final price (with any applicable discount)
    const finalPrice = AppState.selectedTimeSlot.finalPrice || AppState.selectedTimeSlot.price;

    // First try with the most direct approach possible - find "Amount:" label and select next element
    const amountLabels = document.querySelectorAll('.payment-label');
    for (let i = 0; i < amountLabels.length; i++) {
      if (amountLabels[i].textContent.trim() === 'Amount:') {
        // Found the Amount label, now get the next element which should be the value
        const amountValue = amountLabels[i].nextElementSibling;
        if (amountValue && amountValue.classList.contains('payment-value')) {
          amountValue.textContent = `EGP ${finalPrice.toFixed(2)}`;
          console.log("Updated amount via label-next-sibling approach");
          break;
        }
      }
    }

    // Generate a unique reference number if not already set
    const refNumElement = document.getElementById('payment-ref-num');
    if (refNumElement && !refNumElement.textContent) {
      const refNum = Utils.generateReferenceNumber();
      refNumElement.textContent = refNum;
    }
  };

  // Alternative direct update function using direct DOM targeting
  // Now using EGP consistently
  function updateInstapayAmount() {
    // This directly targets and updates the amount field
    // Add this to your code where needed

    if (!AppState.selectedTimeSlot) return;

    // Get the final price (with any applicable discount)
    const finalPrice = AppState.selectedTimeSlot.finalPrice || AppState.selectedTimeSlot.price;

    // Direct document.querySelector approach - add a data attribute to the HTML if possible
    document.querySelectorAll('.payment-details-grid').forEach(grid => {
      const labels = grid.querySelectorAll('.payment-label');
      const values = grid.querySelectorAll('.payment-value');

      for (let i = 0; i < labels.length; i++) {
        if (labels[i].textContent.trim() === 'Amount:') {
          if (values[i]) {
            values[i].textContent = `EGP ${finalPrice.toFixed(2)}`;
            console.log("Updated amount via grid-index matching");
            return;
          }
        }
      }
    });
  }

  // For direct DOM manipulation - can be used in the console for testing
  // Now using EGP consistently
  function directlyUpdateAmount(amount) {
    document.querySelectorAll('.payment-details-grid .payment-value')[0].textContent = `EGP ${amount.toFixed(2)}`;
  }


  // ===== CANCEL MODAL =====
  const CancelModal = {
    open: (bookingId) => {
      const cancelYes = DOM.byId('cancel-yes');
      if (cancelYes) {
        cancelYes.setAttribute('data-booking-id', bookingId);

        // Add one-time event listener
        cancelYes.addEventListener('click', function () {
          CancelModal.cancelBooking(this.getAttribute('data-booking-id'));
        }, { once: true });
      }

      const cancelModal = DOM.byId('cancel-modal');
      if (cancelModal) {
        DOM.addClass(cancelModal, 'active');
        document.body.style.overflow = 'hidden';
      }
    },

    hide: () => {
      const cancelModal = DOM.byId('cancel-modal');
      if (cancelModal) {
        DOM.removeClass(cancelModal, 'active');
        document.body.style.overflow = '';
      }

      // Reset booking reference when modal is closed
      AppState.resetBookingReference();

      // Reset submission locks
      if (API.activeRequests) {
        // Clear any hanging requests
        for (const key in API.activeRequests) {
          if (key.startsWith('addBookingToBuffer_') || key.startsWith('addBookingToDatabase_')) {
            delete API.activeRequests[key];
          }
        }
      }
    },

    cancelBooking: (bookingId) => {
      const bookingIndex = bookings.findIndex(b => b.id === parseInt(bookingId));

      if (bookingIndex !== -1) {
        // Update booking status
        bookings[bookingIndex].status = 'CANCELED';

        // Remove from booked slots
        const booking = bookings[bookingIndex];
        const bookedSlotIndex = bookedSlots.findIndex(slot =>
          slot.resourceId === booking.resourceId &&
          slot.date === booking.date &&
          slot.startTime === booking.startTime &&
          slot.endTime === booking.endTime
        );

        if (bookedSlotIndex !== -1) {
          bookedSlots.splice(bookedSlotIndex, 1);
        }

        // Hide cancel modal
        CancelModal.hide();

        // Show success toast
        Toast.show('success', 'Booking canceled successfully');

        // Re-render bookings
        UI.renderBookings();
      }
    }
  };

  // ===== MODIFY THE API MODULE =====
  // Using Google Apps Script's google.script.run for server communication

  // ===== API MODULE =====
  // Using Google Apps Script's google.script.run for server communication

  const API = {
    // Track active requests by function name
    activeRequests: {},

    /**
     * Core request method that handles all API calls to Google Apps Script
     * @param {string} functionName - Server-side function to call
     * @param {object} data - Optional data to send to the server
     * @param {object} options - Optional configuration
     * @returns {Promise} Promise that resolves with the response
     */
    request: function (functionName, data = {}, options = {}) {
      const {
        showLoader = true,
        loaderMessage = 'Processing Request',
        loaderTitle = 'Please Wait',
        hideToastOnSuccess = false,
        successMessage = 'Operation completed successfully',
        errorMessage = 'Operation failed. Please try again.',
        preventDuplicateSubmission = true,
        requestId = functionName
      } = options;

      const trackingId = requestId;

      if (preventDuplicateSubmission && this.activeRequests[trackingId]) {
        console.warn(`Preventing duplicate submission for: ${trackingId}`);
        return Promise.reject(new Error(`Request ${trackingId} already in progress`));
      }

      if (preventDuplicateSubmission) {
        this.activeRequests[trackingId] = true;
        console.log(`Starting request: ${trackingId}`);
      }

      return new Promise((resolve, reject) => {
        if (showLoader) {
          LoadingManager.showFullPageLoader(loaderTitle, loaderMessage);
        }

        google.script.run
          .withSuccessHandler(function (response) {
            if (showLoader) {
              LoadingManager.hideFullPageLoader();
            }

            if (!hideToastOnSuccess) {
              Toast.show('success', successMessage);
            }

            if (preventDuplicateSubmission) {
              delete API.activeRequests[trackingId];
              console.log(`Completed request: ${trackingId}`);
            }

            resolve(response);
          })
          .withFailureHandler(function (error) {
            console.error(`API Error (${functionName}):`, error);

            if (showLoader) {
              LoadingManager.hideFullPageLoader();
            }

            Toast.show('error', errorMessage);

            if (preventDuplicateSubmission) {
              delete API.activeRequests[trackingId];
              console.log(`Failed request: ${trackingId}`);
            }

            reject(error);
          })
        [functionName](data);
      });
    },

    /**
     * Fetch resources from the server
     * @returns {Promise} Promise that resolves with processed resources
     */
    fetchResourcesAndSlots: function () {
      // Don't reload if already loaded
      if (AppState.dataLoaded.resources && window.resources && window.resources.length > 0) {
        console.log('Resources already loaded, using cached data');
        return Promise.resolve(window.resources);
      }

      return this.request('fetchResourcesAndSlots', {}, {
        requestId: 'fetchResources',
        loaderTitle: 'Loading Resources',
        loaderMessage: 'Fetching available resources...',
        hideToastOnSuccess: true,
        errorMessage: 'Failed to load resources. Please try again.',
        showLoader: false
      })
        .then(response => {
          try {
            const data = typeof response === 'string' ? JSON.parse(response) : response;
            console.log('Resources data loaded:', data);

            if (Array.isArray(data)) {
              window.resources = data;
              AppState.dataLoaded.resources = true;
              return data;
            } else if (data && data.krooResourcesRooms) {
              const processedResources = data.krooResourcesRooms.map(resource => ({
                id: resource.id,
                name: resource.name,
                image: resource.image || '/api/placeholder/400/260',
                capacity: resource.capacity || 0,
                status: resource.status || 'available',
                location: resource.location || 'Not specified',
                pricePerHour: resource.pricePerHour || 100,
                carouselImages: resource.carouselImages || [],
                resourceLabel: resource.resourceLabel || ''
              }));

              resources = processedResources;
              bookedSlots = data.bookedSlots;
              AppState.dataLoaded.resources = true;
              AppState.dataLoaded.bookedSlots = true;
              return processedResources;
            } else {
              throw new Error('Invalid data format');
            }
          } catch (error) {
            console.error('Error processing resources data:', error);
            if (window.resources && window.resources.length > 0) {
              console.warn('Falling back to existing resources data');
              AppState.dataLoaded.resources = true;
              AppState.dataLoaded.bookedSlots = true;
              return window.resources;
            } else {
              throw error;
            }
          }
        })
        .catch(error => {
          console.log(error)
          if (window.resources && window.resources.length > 0) {
            console.warn('Falling back to existing resources data due to API error');
            AppState.dataLoaded.resources = true;
            return window.resources;
          } else {
            throw error;
          }
        });
    },

    fetchBookings: function () {
      console.log('=== API.fetchBookings called ===');
      console.log('AppState.initialMode:', AppState.initialMode);
      console.log('Current bookings array length:', bookings.length);

      // GUEST MODE: Don't fetch from database, use cookies only
      if (AppState.initialMode === 'guest') {
        console.log('✅ GUEST MODE - Loading bookings from cookies');

        const bookingsView = DOM.byId('bookings-view');
        if (bookingsView && bookingsView.style.display !== 'none') {
          UI.showBookingSkeletons();
        }

        return new Promise(resolve => {
          setTimeout(() => {
            console.log('Getting guest bookings from cookies...');
            const guestBookings = BookingStorage.getGuestBookings();
            console.log('Guest bookings from cookies:', guestBookings);

            // IMPORTANT: Update the global bookings array
            bookings = guestBookings;
            console.log('Updated global bookings array to:', bookings);

            AppState.dataLoaded.bookings = true;

            console.log(`✅ Loaded ${guestBookings.length} guest bookings from cookies`);

            const currentBookingsView = DOM.byId('bookings-view');
            if (currentBookingsView && currentBookingsView.style.display !== 'none') {
              console.log('Calling UI.renderBookings()...');
              UI.renderBookings();
            }

            resolve(guestBookings);
          }, 500);
        });
      }

      // USER MODE: Fetch only user's bookings from database
      if (AppState.initialMode === 'user') {
        console.log('User mode: Fetching user bookings from database');

        if (AppState.dataLoaded.bookings) {
          console.log('User bookings already loaded, using cached data');
          return Promise.resolve(bookings);
        }

        const bookingsView = DOM.byId('bookings-view');
        if (bookingsView && bookingsView.style.display !== 'none') {
          UI.showBookingSkeletons();
        }

        return this.request('fetchUserBookings', { userEmail: AppState.userEmail }, {
          requestId: 'fetchUserBookings',
          loaderTitle: 'Loading Your Bookings',
          loaderMessage: 'Fetching your reservations...',
          hideToastOnSuccess: true,
          errorMessage: 'Failed to load your bookings. Please try again.',
          showLoader: false
        })
          .then(response => {
            try {
              const data = typeof response === 'string' ? JSON.parse(response) : response;
              console.log('User bookings data loaded:', data);

              bookings = data.bookings || data || [];
              AppState.dataLoaded.bookings = true;

              console.log(`Loaded ${bookings.length} bookings for user: ${AppState.userEmail}`);

              const currentBookingsView = DOM.byId('bookings-view');
              if (currentBookingsView && currentBookingsView.style.display !== 'none') {
                UI.renderBookings();
              }

              return bookings;
            } catch (error) {
              console.error('Error processing user bookings data:', error);
              AppState.dataLoaded.bookings = true;

              const currentBookingsView = DOM.byId('bookings-view');
              if (currentBookingsView && currentBookingsView.style.display !== 'none') {
                UI.renderBookings();
              }

              return bookings;
            }
          })
          .catch(error => {
            console.error('Error fetching user bookings:', error);
            AppState.dataLoaded.bookings = true;

            const currentBookingsView = DOM.byId('bookings-view');
            if (currentBookingsView && currentBookingsView.style.display !== 'none') {
              UI.renderBookings();
            }

            return bookings;
          });
      }

      // ADMIN MODE: Fetch ALL bookings from database
      if (AppState.initialMode === 'admin') {
        console.log('Admin mode: Fetching all bookings from database');

        if (AppState.dataLoaded.bookings) {
          console.log('Admin bookings already loaded, using cached data');
          return Promise.resolve(bookings);
        }

        const bookingsView = DOM.byId('bookings-view');
        if (bookingsView && bookingsView.style.display !== 'none') {
          UI.showBookingSkeletons();
        }

        return this.request('fetchAllBookings', {}, {
          requestId: 'fetchAllBookings',
          loaderTitle: 'Loading All Bookings',
          loaderMessage: 'Fetching all reservations...',
          hideToastOnSuccess: true,
          errorMessage: 'Failed to load bookings. Please try again.',
          showLoader: false
        })
          .then(response => {
            try {
              const data = typeof response === 'string' ? JSON.parse(response) : response;
              console.log('Admin bookings data loaded:', data);

              bookings = data.bookings || data || [];
              AppState.dataLoaded.bookings = true;

              console.log(`Loaded ${bookings.length} bookings for admin`);

              const currentBookingsView = DOM.byId('bookings-view');
              if (currentBookingsView && currentBookingsView.style.display !== 'none') {
                UI.renderBookings();
              }

              return bookings;
            } catch (error) {
              console.error('Error processing admin bookings data:', error);
              AppState.dataLoaded.bookings = true;

              const currentBookingsView = DOM.byId('bookings-view');
              if (currentBookingsView && currentBookingsView.style.display !== 'none') {
                UI.renderBookings();
              }

              return bookings;
            }
          })
          .catch(error => {
            console.error('Error fetching admin bookings:', error);
            AppState.dataLoaded.bookings = true;

            const currentBookingsView = DOM.byId('bookings-view');
            if (currentBookingsView && currentBookingsView.style.display !== 'none') {
              UI.renderBookings();
            }

            return bookings;
          });
      }

      console.log('No mode matched, returning empty array');
      return Promise.resolve([]);
    },

    /**
     * Add booking to buffer (first stage - wait for response)
     * @param {object} bookingData - Complete booking data with reference
     * @returns {Promise} Promise resolving to booking with ID and reference
     */
    addToBuffer: function (bookingData) {
      if (!bookingData.reference) {
        bookingData.reference = Utils.generateBookingReference();
      }

      if (!bookingData.bufferTimestamp) {
        bookingData.bufferTimestamp = Date.now();
      }

      const requestId = `addBookingToBuffer_${bookingData.reference}`;

      return this.request('addBookingToBuffer', bookingData, {
        requestId: requestId,
        loaderTitle: 'Processing Booking',
        loaderMessage: 'Please wait while we confirm your reservation...',
        hideToastOnSuccess: true,
        errorMessage: 'Could not process your booking. Please try again.'
      });
    },

    /**
     * Add booking to database (second stage - don't wait for response)
     * @param {object} bookingData - Booking data from buffer
     */
    addToDatabase: function (bookingData) {
      const dbBookingData = {
        ...bookingData,
        dbTimestamp: Date.now()
      };

      const requestId = `addBookingToDatabase_${bookingData.reference}`;

      return this.request('addBookingToDatabase', dbBookingData, {
        requestId: requestId,
        showLoader: false,
        hideToastOnSuccess: true,
        preventDuplicateSubmission: true
      })
        .then(response => {
          console.log('Booking added to database:', response);
          return response;
        })
        .catch(error => {
          console.error('Error adding booking to database:', error);
          throw error;
        });
    },

    /**
     * Verify InstaPay payment
     * @param {File} file - Screenshot file
     * @param {string} paymentReference - Booking reference
     * @param {number} expectedAmount - Expected payment amount
     * @param {object} verificationOptions - Verification options
     * @returns {Promise} Promise resolving to verification result
     */
    verifyInstapayPayment: function (file, paymentReference, expectedAmount, verificationOptions) {
      const verifyButton = document.getElementById('verify-payment');
      if (verifyButton) {
        LoadingManager.showButtonLoader('#verify-payment');
      }

      const requestId = `verifyInstapayPayment_${paymentReference}`;

      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          try {
            const base64Data = e.target.result.split(',')[1];

            const dataToSend = {
              fileContent: base64Data,
              fileName: file.name,
              fileType: file.type,
              fileSize: file.size,
              paymentReference: paymentReference,
              expectedAmount: expectedAmount,
              ...verificationOptions
            };

            console.log("Sending file:", file.name, "size:", file.size, "type:", file.type);
            console.log("With reference:", paymentReference, "expected amount:", expectedAmount);

            this.request('processFullVerification', dataToSend, {
              requestId: requestId,
              loaderTitle: 'Verifying Payment',
              loaderMessage: 'Please wait while we verify your payment...',
              hideToastOnSuccess: true,
              errorMessage: 'Could not verify payment. Please try again.'
            })
              .then(resolve)
              .catch(reject);
          }
          catch (error) {
            console.error('Error preparing file data:', error);
            reject(error);
          }
        };

        reader.onerror = (error) => {
          console.error('Error reading file:', error);
          reject(error);
        };

        reader.readAsDataURL(file);
      });
    },

    /**
     * Cancel a booking
     * @param {number} bookingId - ID of booking to cancel
     * @returns {Promise} Promise that resolves with canceled booking
     */
    cancelBooking: function (bookingId) {
      const requestId = `cancelBooking_${bookingId}`;

      return this.request('cancelBooking', { bookingId }, {
        requestId: requestId,
        loaderTitle: 'Canceling Booking',
        loaderMessage: 'Please wait while we process your cancellation...',
        successMessage: 'Booking canceled successfully!'
      });
    }
  };

  // ===== EVENT HANDLERS =====
  // Setup global event listeners
  const setupEventListeners = () => {
    // Navigation
    const tabResources = DOM.byId('tab-resources');
    const tabBookings = DOM.byId('tab-bookings');

    if (tabResources) {
      tabResources.addEventListener('click', UI.showResourcesView);
    }

    if (tabBookings) {
      tabBookings.addEventListener('click', UI.showBookingsView);
    }

    // Booking filters
    const filterUpcoming = DOM.byId('filter-upcoming');
    const filterPast = DOM.byId('filter-past');

    if (filterUpcoming) {
      filterUpcoming.addEventListener('click', () => UI.setBookingFilter('upcoming'));
    }

    if (filterPast) {
      filterPast.addEventListener('click', () => UI.setBookingFilter('past'));
    }

    // Modal close buttons
    const modalCloseButtons = document.querySelectorAll('.modal-close');
    modalCloseButtons.forEach(button => {
      button.addEventListener('click', () => {
        const modalId = button.closest('.modal').id;
        if (modalId === 'booking-modal') {
          BookingModal.hide();
        } else if (modalId === 'cancel-modal') {
          CancelModal.hide();
        }
      });
    });

    const continueToPayment = DOM.byId('continue-to-payment');
    if (continueToPayment) {
      continueToPayment.addEventListener('click', BookingModal.continueToPayment);
    }

    const backToSelection = DOM.byId('back-to-selection');
    if (backToSelection) {
      backToSelection.addEventListener('click', () => {
        BookingModal.hideAllSteps();
        DOM.show(DOM.byId('booking-step-1'));
      });
    }

    const proceedToPayment = DOM.byId('proceed-to-payment');
    if (proceedToPayment) {
      proceedToPayment.addEventListener('click', BookingModal.proceedToPaymentDetails);
    }

    const backToMethods = DOM.byId('back-to-methods');
    if (backToMethods) {
      backToMethods.addEventListener('click', () => {
        BookingModal.hideAllSteps();
        DOM.show(DOM.byId('booking-step-2'));
      });
    }

    const backToMethodsFromCard = DOM.byId('back-to-methods-from-card');
    if (backToMethodsFromCard) {
      backToMethodsFromCard.addEventListener('click', () => {
        BookingModal.hideAllSteps();
        DOM.show(DOM.byId('booking-step-2'));
      });
    }

    const backToMethodsFromOther = DOM.byId('back-to-methods-from-other');
    if (backToMethodsFromOther) {
      backToMethodsFromOther.addEventListener('click', () => {
        BookingModal.hideAllSteps();
        DOM.show(DOM.byId('booking-step-2'));
      });
    }

    const verifyPayment = DOM.byId('verify-payment');
    if (verifyPayment) {
      verifyPayment.addEventListener('click', BookingModal.verifyPayment);
    }

    // Confirmation button after verification
    const confirmBooking = DOM.byId('confirm-booking');
    if (confirmBooking) {
      confirmBooking.addEventListener('click', () => {
        BookingModal.hide();
        Toast.show('success', 'Your booking is confirmed! Check My Bookings to see details.');
        UI.renderResources();
      });
    }

    const processCardPayment = DOM.byId('process-card-payment');
    if (processCardPayment) {
      processCardPayment.addEventListener('click', BookingModal.processCardPayment);
    }

    const continueToExternal = DOM.byId('continue-to-external');
    if (continueToExternal) {
      continueToExternal.addEventListener('click', BookingModal.continueToExternalPayment);
    }

    // File upload
    const paymentScreenshot = DOM.byId('payment-screenshot');
    if (paymentScreenshot) {
      paymentScreenshot.addEventListener('change', BookingModal.handleFileUpload);
    }

    // Cancel modal
    const cancelNo = DOM.byId('cancel-no');
    if (cancelNo) {
      cancelNo.addEventListener('click', CancelModal.hide);
    }

    // Image carousel event listeners
    const carouselClose = DOM.byId('carousel-close');
    if (carouselClose) {
      carouselClose.addEventListener('click', ImageCarousel.hide.bind(ImageCarousel));
    }

    const carouselPrev = DOM.byId('carousel-prev');
    if (carouselPrev) {
      carouselPrev.addEventListener('click', ImageCarousel.prevSlide.bind(ImageCarousel));
    }

    const carouselNext = DOM.byId('carousel-next');
    if (carouselNext) {
      carouselNext.addEventListener('click', ImageCarousel.nextSlide.bind(ImageCarousel));
    }

    const carouselModal = DOM.byId('image-carousel-modal');
    if (carouselModal) {
      carouselModal.addEventListener('click', function (event) {
        if (event.target === this) {
          ImageCarousel.hide();
        }
      });
    }
    // KEYBOARD NAVIGATION - This is the important one for arrow keys
    document.addEventListener('keydown', ImageCarousel.handleKeyboard.bind(ImageCarousel));
  };

  // ===== INITIALIZATION =====
  // Updated DOMContentLoaded event listener with loading screens initialization
  // Add this to your initialization code

  document.addEventListener('DOMContentLoaded', () => {
    try {
      console.log('Initializing KROO Reservations App...');

      // Show initial loading screen
      LoadingManager.showFullPageLoader('Initializing', 'Setting up KROO Reservations...');

      // Create loader elements
      const fullPageLoader = document.createElement('div');
      fullPageLoader.className = 'full-page-loader';
      fullPageLoader.innerHTML = `
      <div class="loader-content">
        <div class="loader-icon">
          <div class="loader-spinner"></div>
        </div>
        <h3 class="loader-title">Loading</h3>
        <p class="loader-message">Please wait...</p>
      </div>
    `;
      document.body.appendChild(fullPageLoader);

      // Initialize user from URL parameters
      AppState.initializeUser();

      // Setup welcome banner
      setupWelcomeBanner();

      // Store original resources data as fallback
      window.resources = [...resources];

      // Setup event listeners
      setupEventListeners();

      // Render resources (this will now include its own loading indicators)
      UI.renderResources();

      // ADD THIS LINE - Start loading bookings in parallel
      API.fetchBookings();

      // Hide initial loading screen after a short delay
      setTimeout(() => {
        LoadingManager.hideFullPageLoader();
        console.log('KROO Reservations App initialized successfully');
      }, 1000);
    } catch (error) {
      // Hide loader if there's an error
      LoadingManager.hideFullPageLoader();
      console.error('Error initializing application:', error);
      Toast.show('error', 'Could not initialize the application. Please refresh the page.');
    }
  });

  // ===== PERFORMANCE METRICS (OPTIONAL) =====
  const PerformanceTracker = {
    startTime: Date.now(),

    logPhase: function (phaseName) {
      const elapsed = Date.now() - this.startTime;
      console.log(`🚀 ${phaseName} completed in ${elapsed}ms`);
    },

    logAppReady: function () {
      const elapsed = Date.now() - this.startTime;
      console.log(`✅ App ready for use in ${elapsed}ms`);
    }
  };

  // ===== COOKIE STORAGE UTILITIES =====

  const CookieStorage = {
    /**
     * Set a cookie
     * @param {string} name - Cookie name
     * @param {string|object} value - Cookie value (will be JSON stringified if object)
     * @param {number} days - Expiration in days (default: 30)
     */
    set: function (name, value, days = 30) {
      try {
        const stringValue = typeof value === 'object' ? JSON.stringify(value) : value;
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = "expires=" + date.toUTCString();

        // Use the same cookie settings that work for you
        const cookieString = `${name}=${stringValue};${expires};path=/;SameSite=none;secure`;

        console.log('Setting cookie:', name);
        console.log('Cookie string:', cookieString);
        console.log('Value being stored:', value);

        document.cookie = cookieString;

        // Verify it was set
        const verification = this.get(name);
        console.log('Cookie verification after setting:', verification);

        console.log(`Cookie set: ${name}`);
      } catch (error) {
        console.error('Error setting cookie:', error);
      }
    },

    /**
     * Get a cookie
     * @param {string} name - Cookie name
     * @param {boolean} parseJson - Whether to parse as JSON (default: false)
     * @returns {string|object|null} Cookie value
     */
    get: function (name, parseJson = false) {
      try {
        const nameEQ = name + "=";
        const cookies = document.cookie.split(';');

        for (let i = 0; i < cookies.length; i++) {
          let cookie = cookies[i];
          while (cookie.charAt(0) === ' ') {
            cookie = cookie.substring(1, cookie.length);
          }
          if (cookie.indexOf(nameEQ) === 0) {
            const value = cookie.substring(nameEQ.length, cookie.length);
            return parseJson ? JSON.parse(value) : value;
          }
        }
        return null;
      } catch (error) {
        console.error('Error getting cookie:', error);
        return null;
      }
    },

    /**
     * Delete a cookie
     * @param {string} name - Cookie name
     */
    delete: function (name) {
      // Use the same settings that work for setting cookies
      document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=none; secure`;
      console.log(`Cookie deleted: ${name}`);
    },

    /**
     * Check if a cookie exists
     * @param {string} name - Cookie name
     * @returns {boolean}
     */
    exists: function (name) {
      return this.get(name) !== null;
    }
  };

  // ===== BOOKING STORAGE =====

  const BookingStorage = {
    /**
     * Store guest booking data in cookies
     */
    storeGuestBooking: function (bookingData) {
      try {
        const existingBookings = this.getGuestBookings();

        const guestBooking = {
          id: Date.now(),
          reference: bookingData.reference,
          resourceId: bookingData.resourceId,
          resourceName: bookingData.resourceName,
          date: bookingData.date,
          startTime: bookingData.startTime,
          endTime: bookingData.endTime,
          price: bookingData.price,
          paymentMethod: bookingData.paymentMethod,
          paymentStatus: bookingData.paymentStatus || 'completed',
          status: 'CONFIRMED',
          userDetails: bookingData.userDetails,
          createdAt: bookingData.createdAt || new Date().toISOString(),
          timestamp: Date.now(),
          isGuestBooking: true
        };

        existingBookings.push(guestBooking);

        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
        const recentBookings = existingBookings.filter(booking =>
          booking.timestamp > thirtyDaysAgo
        );

        const bookingsToStore = recentBookings.slice(-20);
        CookieStorage.set('guest_bookings', bookingsToStore, 30);

        console.log('Guest booking stored in cookie:', guestBooking.reference);
        return guestBooking;
      } catch (error) {
        console.error('Error storing guest booking:', error);
        return null;
      }
    },

    getGuestBookings: function () {
      try {
        const bookings = CookieStorage.get('guest_bookings', true) || [];

        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
        const validBookings = bookings.filter(booking =>
          booking.timestamp > thirtyDaysAgo
        );

        if (validBookings.length !== bookings.length) {
          CookieStorage.set('guest_bookings', validBookings, 30);
        }

        return validBookings;
      } catch (error) {
        console.error('Error getting guest bookings:', error);
        return [];
      }
    },

    updateGuestBookingStatus: function (bookingId, newStatus) {
      try {
        const bookings = this.getGuestBookings();
        const bookingIndex = bookings.findIndex(b => b.id === parseInt(bookingId));

        if (bookingIndex !== -1) {
          bookings[bookingIndex].status = newStatus;
          bookings[bookingIndex].updatedAt = new Date().toISOString();

          CookieStorage.set('guest_bookings', bookings, 30);
          console.log(`Guest booking ${bookingId} status updated to ${newStatus}`);
          return true;
        }

        return false;
      } catch (error) {
        console.error('Error updating guest booking status:', error);
        return false;
      }
    },

    canCancelBooking: function (booking) {
      if (!booking || booking.status === 'CANCELED' || booking.status === 'EXPIRED') {
        return false;
      }

      const bookingEndTime = new Date(`${booking.date}T${booking.endTime}`);
      const now = new Date();

      return bookingEndTime > now;
    },

    clearGuestBookings: function () {
      CookieStorage.delete('guest_bookings');
      console.log('All guest bookings cleared');
    },

    // Keep existing methods
    storeRecentBooking: function (bookingData) {
      const bookingInfo = {
        reference: bookingData.reference,
        resourceName: bookingData.resourceName,
        date: bookingData.date,
        startTime: bookingData.startTime,
        endTime: bookingData.endTime,
        price: bookingData.price,
        paymentMethod: bookingData.paymentMethod,
        timestamp: Date.now()
      };

      CookieStorage.set('recent_booking', bookingInfo, 7);
      console.log('Recent booking stored in cookie');
    },

    getRecentBooking: function () {
      const booking = CookieStorage.get('recent_booking', true);

      if (booking) {
        const age = Date.now() - booking.timestamp;
        const maxAge = 7 * 24 * 60 * 60 * 1000;

        if (age < maxAge) {
          return booking;
        } else {
          this.clearRecentBooking();
          return null;
        }
      }

      return null;
    },

    clearRecentBooking: function () {
      CookieStorage.delete('recent_booking');
    },

    storeUserPreferences: function (preferences) {
      CookieStorage.set('user_preferences', preferences, 365);
    },

    getUserPreferences: function () {
      return CookieStorage.get('user_preferences', true) || {
        preferredPaymentMethod: '',
        rememberBookingDetails: true,
        showTutorial: true
      };
    }
  };

  // Simple cookie test
  // setTimeout(() => {
  //   if (AppState.getUserMode() === 'guest') {
  //     console.log('Testing cookie storage...');
  //     // CookieStorage.set('test_cookie', 'test_value', 1);
  //     // console.log('Basic cookie test result:', CookieStorage.get('test_cookie'));

  //     const testBooking = {
  //       id: 999999,
  //       reference: 'TEST-123',
  //       resourceName: 'Test Room',
  //       date: '2025-01-01',
  //       startTime: '10:00',
  //       endTime: '11:00',
  //       price: 100,
  //       isGuestBooking: true
  //     };

  //     console.log('Storing test booking...');
  //     const result = BookingStorage.storeGuestBooking(testBooking);
  //     console.log('Store result:', result);

  //     const retrieved = BookingStorage.getGuestBookings();
  //     console.log('Retrieved bookings:', retrieved);

  //     console.log('Raw cookies:', document.cookie);

  //     // Test deletion
  //     console.log('Testing deletion...');
  //     BookingStorage.clearGuestBookings();
  //     console.log('After deletion:', BookingStorage.getGuestBookings());
  //     console.log('Raw cookies after deletion:', document.cookie);
  //   }
  // }, 2000);
</script>